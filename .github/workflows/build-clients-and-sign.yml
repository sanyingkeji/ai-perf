name: Build Clients (With Signing & Notarization)

on:
  release:
    types: [published]
  push:
    tags:
      - 'v*'  # 监听以 v 开头的 tag 推送
  workflow_dispatch:
    inputs:
      client_type:
        description: '客户端类型'
        required: true
        type: choice
        options:
          - employee
          - admin
          - both
        default: both
      platforms:
        description: '打包平台'
        required: true
        type: choice
        options:
          - all
          - macos
          - windows
          - linux
        default: all

jobs:
  build-macos-arm64:
    name: Build macOS (Apple Silicon)
    runs-on: macos-14  # macOS 14 (Sonoma) 支持最低 10.13
    timeout-minutes: 180  # 3小时超时
    if: >
      github.event_name == 'release' ||
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) ||
      (github.event_name == 'workflow_dispatch' &&
        (github.event.inputs.platforms == 'all' || github.event.inputs.platforms == 'macos' || github.event.inputs.platforms == ''))
    strategy:
      matrix:
        client: [employee, admin]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pyenv
        run: |
          echo "安装 pyenv..."
          # 安装 pyenv 依赖
          brew install openssl readline sqlite3 xz zlib tcl-tk || true
          # 安装 pyenv
          curl https://pyenv.run | bash || {
            # 如果 curl 失败，尝试使用 git clone
            git clone https://github.com/pyenv/pyenv.git ~/.pyenv || true
          }
          # 设置 pyenv 环境变量（用于后续步骤）
          export PYENV_ROOT="$HOME/.pyenv"
          export PATH="$PYENV_ROOT/bin:$PATH"
          echo "PYENV_ROOT=$PYENV_ROOT" >> $GITHUB_ENV
          echo "PATH=$PYENV_ROOT/bin:$PATH" >> $GITHUB_ENV
          # 验证 pyenv 安装
          "$PYENV_ROOT/bin/pyenv" --version || echo "警告: pyenv 安装可能失败"
      
      - name: Install Python 3.10.4 with pyenv
        run: |
          export PYENV_ROOT="${{ env.PYENV_ROOT || '$HOME/.pyenv' }}"
          export PATH="$PYENV_ROOT/bin:$PATH"
          eval "$(pyenv init - bash)"
          echo "使用 pyenv 安装 Python 3.10.4..."
          # 设置部署目标为 10.13，确保向后兼容性
          # 问题分析：
          # - 之前没有设置 MACOSX_DEPLOYMENT_TARGET，Python 使用了默认值（14.7）
          # - 导致 Python 库链接了 macOS 13+ 的符号（如 _mkfifoat）
          # - _mkfifoat 符号在 macOS 13.0+ 才可用，在 macOS 12.7.6 上会找不到
          # 解决方案：
          # - 在编译 Python 时设置 MACOSX_DEPLOYMENT_TARGET=10.13
          # - 编译器会检查符号可用性，避免使用 macOS 13+ 的符号
          # - 这样既能支持 macOS 10.13+，又能确保在 macOS 12.7.6 上运行
          export MACOSX_DEPLOYMENT_TARGET=10.13
          export CFLAGS="-mmacosx-version-min=10.13"
          export LDFLAGS="-mmacosx-version-min=10.13"
          export CPPFLAGS="-mmacosx-version-min=10.13"
          # 确保编译器遵守部署目标，避免使用新版本符号
          export CC="clang -mmacosx-version-min=10.13"
          export CXX="clang++ -mmacosx-version-min=10.13"
          echo "设置部署目标: MACOSX_DEPLOYMENT_TARGET=10.13 (支持 macOS 10.13+，避免使用 macOS 13+ 符号)"
          # 安装 Python 3.10.4（这可能需要几分钟）
          pyenv install -s 3.10.4 || {
            echo "警告: Python 3.10.4 安装失败，尝试继续..."
            # 如果安装失败，尝试使用系统 Python
            if [ -f "/Library/Frameworks/Python.framework/Versions/3.10/bin/python3" ]; then
              echo "使用系统 Python 3.10"
              echo "PYTHON_CMD=/Library/Frameworks/Python.framework/Versions/3.10/bin/python3" >> $GITHUB_ENV
            else
              echo "错误: 无法安装或找到 Python 3.10.4"
              exit 1
            fi
          }
          # 设置全局 Python 版本为 3.10.4
          pyenv global 3.10.4 || echo "警告: 无法设置全局 Python 版本"
          # 验证 Python 版本
          pyenv version
          python3 --version
          # 将 Python 路径添加到环境变量
          PYTHON_CMD=$(pyenv which python3)
          echo "Python 路径: $PYTHON_CMD"
          echo "PYTHON_CMD=$PYTHON_CMD" >> $GITHUB_ENV
      
      - name: Install dependencies
        env:
          MACOSX_DEPLOYMENT_TARGET: '10.13'
        run: |
          # 使用 pyenv 的 Python（如果已安装）
          if [ -n "${{ env.PYTHON_CMD }}" ] && [ -f "${{ env.PYTHON_CMD }}" ]; then
            PYTHON="${{ env.PYTHON_CMD }}"
            echo "使用 pyenv Python: $PYTHON"
            # pyenv Python 不需要 --break-system-packages 选项
            "$PYTHON" -m pip install --upgrade pip
            "$PYTHON" -m pip install -r requirements.txt
          else
            # 回退到系统 Python（需要 --break-system-packages）
            export PYENV_ROOT="${{ env.PYENV_ROOT || '$HOME/.pyenv' }}"
            export PATH="$PYENV_ROOT/bin:$PATH"
            eval "$(pyenv init - bash)" || true
            python3 -m pip install --upgrade pip --break-system-packages
            pip3 install -r requirements.txt --break-system-packages
          fi
      
      - name: Verify PyInstaller installation
        run: |
          # 使用 pyenv 的 Python（如果已安装）
          if [ -n "${{ env.PYTHON_CMD }}" ] && [ -f "${{ env.PYTHON_CMD }}" ]; then
            PYTHON="${{ env.PYTHON_CMD }}"
          else
            export PYENV_ROOT="${{ env.PYENV_ROOT || '$HOME/.pyenv' }}"
            export PATH="$PYENV_ROOT/bin:$PATH"
            eval "$(pyenv init - bash)" || true
            PYTHON="python3"
          fi
          echo "验证 PyInstaller 安装..."
          "$PYTHON" -m PyInstaller --version || echo "警告: PyInstaller 未正确安装"
          "$PYTHON" -m pip list | grep -i pyinstaller || echo "警告: 未找到 PyInstaller 包"
      
      - name: Check if should build
        id: check_build
        run: |
          if [ "${{ github.event_name }}" == "release" ] || \
             [ "${{ github.event_name }}" == "push" ] || \
             [ "${{ github.event.inputs.client_type }}" == "both" ] || \
             [ "${{ github.event.inputs.client_type }}" == "${{ matrix.client }}" ] || \
             [ "${{ github.event.inputs.client_type }}" == "" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi

      - name: Print environment diagnostics
        if: steps.check_build.outputs.should_build == 'true'
        run: |
          # 使用 pyenv 的 Python（如果已安装）
          if [ -n "${{ env.PYTHON_CMD }}" ] && [ -f "${{ env.PYTHON_CMD }}" ]; then
            PYTHON="${{ env.PYTHON_CMD }}"
          else
            export PYENV_ROOT="${{ env.PYENV_ROOT || '$HOME/.pyenv' }}"
            export PATH="$PYENV_ROOT/bin:$PATH"
            eval "$(pyenv init - bash)" || true
            PYTHON="python3"
          fi
          echo "========================================"
          echo "GitHub Actions 环境诊断信息 (Apple Silicon)"
          echo "========================================"
          echo "Python 版本:"
          "$PYTHON" --version
          echo "Python 路径:"
          which "$PYTHON" || echo "$PYTHON"
          echo "PyInstaller 版本:"
          "$PYTHON" -m PyInstaller --version || echo "未安装"
          echo "操作系统信息:"
          sw_vers
          echo "系统版本:"
          uname -a
          echo "文件系统信息:"
          df -T $(pwd) || df $(pwd)
          echo "挂载信息:"
          mount | grep -E "$(df $(pwd) | tail -1 | awk '{print $1}')" || mount | head -5
          echo "环境变量:"
          echo "  MACOSX_DEPLOYMENT_TARGET = ${MACOSX_DEPLOYMENT_TARGET:-未设置}"
          echo "  TMPDIR = ${TMPDIR:-未设置}"
          echo "  HOME = ${HOME:-未设置}"
          echo "  PWD = $(pwd)"
          echo "工作目录路径长度:"
          echo $(pwd) | wc -c
          echo "测试符号链接创建:"
          mkdir -p .symlink_test
          echo "test" > .symlink_test/test_file.txt
          if ln -s test_file.txt .symlink_test/test_link 2>&1; then
            echo "  ✓ 可以创建符号链接"
            ls -la .symlink_test/
          else
            echo "  ✗ 无法创建符号链接"
          fi
          rm -rf .symlink_test
          echo "========================================"
      
      - name: Import Apple Certificate
        if: steps.check_build.outputs.should_build == 'true'
        env:
          APPLICATION_P12_BASE64: ${{ secrets.APPLICATION_P12_BASE64 }}
          APPLICATION_P12_PASSWORD: ${{ secrets.APPLICATION_P12_PASSWORD }}
          INSTALLER_P12_BASE64: ${{ secrets.INSTALLER_P12_BASE64 }}
          INSTALLER_P12_PASSWORD: ${{ secrets.INSTALLER_P12_PASSWORD }}
        run: |
          # 创建临时 keychain 用于签名
          KEYCHAIN_NAME="build.keychain"
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          
          # 创建 keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_NAME"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          
          # 获取 keychain 的完整路径（macOS 可能使用 -db 后缀）
          KEYCHAIN_PATH="$HOME/Library/Keychains/${KEYCHAIN_NAME}-db"
          if [ ! -f "$KEYCHAIN_PATH" ]; then
            KEYCHAIN_PATH="$HOME/Library/Keychains/${KEYCHAIN_NAME}"
          fi
          
          # 设置 keychain 为默认（使用 -d user 确保在用户域中）
          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"
          
          # 导入 Application 证书（如果提供）
          if [ -n "$APPLICATION_P12_BASE64" ]; then
            echo "导入 Developer ID Application 证书..."
            echo "$APPLICATION_P12_BASE64" | base64 --decode > /tmp/application.p12
            if [ -n "$APPLICATION_P12_PASSWORD" ]; then
              security import /tmp/application.p12 -k "$KEYCHAIN_PATH" -P "$APPLICATION_P12_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/productsign || true
            else
              security import /tmp/application.p12 -k "$KEYCHAIN_PATH" -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/productsign || true
            fi
            rm -f /tmp/application.p12
          fi
          
          # 导入 Installer 证书（如果提供）
          if [ -n "$INSTALLER_P12_BASE64" ]; then
            echo "导入 Developer ID Installer 证书..."
            echo "$INSTALLER_P12_BASE64" | base64 --decode > /tmp/installer.p12
            
            # 验证 p12 文件内容（检查是否包含 Installer 证书）
            echo "验证 p12 文件内容..."
            if [ -n "$INSTALLER_P12_PASSWORD" ]; then
              # 尝试从 p12 中提取证书信息
              openssl pkcs12 -in /tmp/installer.p12 -passin pass:"$INSTALLER_P12_PASSWORD" -nokeys -clcerts 2>/dev/null | openssl x509 -noout -subject -issuer 2>/dev/null || echo "无法读取 p12 文件内容（可能需要密码）"
              
              IMPORT_RESULT=$(security import /tmp/installer.p12 -k "$KEYCHAIN_PATH" -P "$INSTALLER_P12_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/productsign 2>&1)
              IMPORT_EXIT_CODE=$?
            else
              IMPORT_RESULT=$(security import /tmp/installer.p12 -k "$KEYCHAIN_PATH" -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/productsign 2>&1)
              IMPORT_EXIT_CODE=$?
            fi
            
            if [ $IMPORT_EXIT_CODE -eq 0 ]; then
              echo "✓ Installer p12 证书导入成功"
              
              # 立即设置 keychain 访问权限（确保 productsign 可以访问）
              echo "设置 Installer 证书的 keychain 访问权限..."
              security set-key-partition-list -S apple-tool:,apple:,codesign:,productsign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH" || true
              
              # 将 keychain 添加到搜索列表（确保证书可以被找到）
              security list-keychains -d user -s "$KEYCHAIN_PATH" || true
              
              # 等待一下，确保证书被索引
              sleep 1
            else
              echo "✗ Installer p12 证书导入失败（退出码: $IMPORT_EXIT_CODE）"
              echo "错误信息: $IMPORT_RESULT"
              echo "可能的原因："
              echo "  1. p12 文件密码错误"
              echo "  2. p12 文件损坏或不完整"
              echo "  3. p12 文件不包含 Installer 证书（可能是 Application 证书）"
              # 不立即退出，让后续步骤显示更详细的错误
            fi
            rm -f /tmp/installer.p12
          else
            echo "⚠ 未提供 INSTALLER_P12_BASE64，跳过 Installer 证书导入"
          fi
          
          # 允许 codesign 和 productsign 访问 keychain（对所有证书）
          echo "设置所有证书的 keychain 访问权限..."
          security set-key-partition-list -S apple-tool:,apple:,codesign:,productsign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH" || true
          
          # 列出可用的签名身份
          echo "可用的签名身份:"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true
          
          # 保存 keychain 信息到环境变量（用于后续步骤）
          echo "KEYCHAIN_NAME=$KEYCHAIN_NAME" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
      
      - name: Build client (Apple Silicon)
        if: steps.check_build.outputs.should_build == 'true'
        env:
          MACOSX_DEPLOYMENT_TARGET: '10.13'
          CFLAGS: '-mmacosx-version-min=10.13'
          LDFLAGS: '-mmacosx-version-min=10.13'
          CPPFLAGS: '-mmacosx-version-min=10.13'
          PYTHONUNBUFFERED: '1'  # 确保 Python 输出无缓冲，实时显示日志
          # 不设置 SKIP_SIGNING，执行完整的签名和公证流程
          GOOGLE_CLIENT_SECRET_JSON: ${{ secrets.GOOGLE_CLIENT_SECRET_JSON }}
          CODESIGN_IDENTITY: ${{ secrets.CODESIGN_IDENTITY }}
          INSTALLER_CODESIGN_IDENTITY: ${{ secrets.INSTALLER_CODESIGN_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          TEAM_ID: ${{ secrets.TEAM_ID }}
          NOTARY_PASSWORD: ${{ secrets.NOTARY_PASSWORD }}
        run: |
          # 确保 keychain 可访问（仅在 GitHub Actions 环境中）
          if [ -n "$KEYCHAIN_NAME" ] && [ -n "$KEYCHAIN_PASSWORD" ]; then
            echo "确保 keychain 可访问..."
            # 获取 keychain 的完整路径
            if [ -n "$KEYCHAIN_PATH" ]; then
              KEYCHAIN_FULL_PATH="$KEYCHAIN_PATH"
            else
              KEYCHAIN_FULL_PATH="$HOME/Library/Keychains/${KEYCHAIN_NAME}-db"
              if [ ! -f "$KEYCHAIN_FULL_PATH" ]; then
                KEYCHAIN_FULL_PATH="$HOME/Library/Keychains/${KEYCHAIN_NAME}"
              fi
            fi
            
            # 将 keychain 添加到搜索列表（使用 -d user 确保是用户域）
            security list-keychains -d user -s "$KEYCHAIN_FULL_PATH" || true
            
            # 重新解锁 keychain
            security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_FULL_PATH" || true
            
            # 设置 keychain 为默认
            security default-keychain -s "$KEYCHAIN_FULL_PATH" || true
            
            # 验证证书是否可用
            echo "验证证书是否可用..."
            security find-identity -v -p codesigning "$KEYCHAIN_FULL_PATH" || {
              echo "⚠ 警告: 在指定 keychain 中查找证书失败，尝试在所有 keychain 中查找..."
              security find-identity -v -p codesigning || true
            }
            
            # 确保 productsign 可以访问 keychain
            security set-key-partition-list -S apple-tool:,apple:,codesign:,productsign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_FULL_PATH" || true
          fi
          
          # 使用 pyenv 的 Python（如果已安装）
          if [ -n "${{ env.PYTHON_CMD }}" ] && [ -f "${{ env.PYTHON_CMD }}" ]; then
            PYTHON="${{ env.PYTHON_CMD }}"
          else
            export PYENV_ROOT="${{ env.PYENV_ROOT || '$HOME/.pyenv' }}"
            export PATH="$PYENV_ROOT/bin:$PATH"
            eval "$(pyenv init - bash)" || true
            PYTHON="python3"
          fi
          cd ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}
          "$PYTHON" ../scripts/build_client.py ${{ matrix.client }} macos
      
      - name: Verify deployment target
        if: steps.check_build.outputs.should_build == 'true'
        run: |
          cd ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}
          # 查找打包后的 .app 文件
          APP_BUNDLE=$(find dist -name "*.app" -type d | head -1)
          if [ -z "$APP_BUNDLE" ]; then
            echo "⚠ 未找到 .app 文件，跳过验证"
            exit 0
          fi
          echo "========================================"
          echo "验证部署目标: $APP_BUNDLE"
          echo "========================================"
          # 检查 Python 库的部署目标
          PYTHON_LIB="$APP_BUNDLE/Contents/Resources/libpython3.10.dylib"
          if [ -f "$PYTHON_LIB" ]; then
            echo "检查 Python 库部署目标:"
            BUILD_VERSION=$(otool -l "$PYTHON_LIB" 2>/dev/null | grep -A 5 "LC_BUILD_VERSION" | grep "minos" || echo "")
            if [ -n "$BUILD_VERSION" ]; then
              echo "  $BUILD_VERSION"
              if echo "$BUILD_VERSION" | grep -q "minos 1[0-1]\."; then
                echo "  ✓ 部署目标正确（macOS 10.x 或 11.x）"
              elif echo "$BUILD_VERSION" | grep -q "minos 12\."; then
                echo "  ✓ 部署目标正确（macOS 12.x）"
              else
                echo "  ⚠ 警告: 部署目标可能过高"
              fi
            else
              echo "  ⚠ 未找到构建版本信息"
            fi
            echo "检查是否引用 macOS 13+ 符号 (_mkfifoat):"
            if nm -u "$PYTHON_LIB" 2>/dev/null | grep -q "_mkfifoat"; then
              echo "  ⚠ 警告: Python 库仍引用 _mkfifoat 符号（macOS 13+）"
              echo "  这可能导致在 macOS 12.7.6 上运行时出错"
            else
              echo "  ✓ Python 库未引用 _mkfifoat 符号"
            fi
          else
            echo "⚠ 未找到 Python 库，跳过验证"
          fi
          echo "========================================"
      
      - name: Fix executable permissions
        if: steps.check_build.outputs.should_build == 'true'
        run: |
          cd ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}
          # 修复 .app 包中主可执行文件的权限（GitHub Actions 打包的文件可能没有执行权限）
          find dist -name "*.app" -type d | while read app_bundle; do
            app_name=$(basename "$app_bundle" .app)
            executable="$app_bundle/Contents/MacOS/$app_name"
            if [ -f "$executable" ]; then
              chmod +x "$executable"
              echo "✓ 修复权限: $executable"
            fi
          done
      
      - name: Cleanup keychain
        if: always() && steps.check_build.outputs.should_build == 'true'
        run: |
          if [ -n "$KEYCHAIN_NAME" ]; then
            security delete-keychain "$KEYCHAIN_NAME" || true
            security list-keychains -d user | grep -v "$KEYCHAIN_NAME" | xargs security list-keychains -d user -s || true
          fi
      
      - name: Upload APP artifact
        if: steps.check_build.outputs.should_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.client }}-macos-arm64-app
          path: ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}/dist/m/*.app
          retention-days: 30

  build-macos-intel:
    name: Build macOS (Intel)
    runs-on: macos-15-intel  # macOS 15 Intel 架构 runner（macOS 13 已废弃，使用新的 macos-15-intel 标签）
    timeout-minutes: 180  # 3小时超时
    if: >
      github.event_name == 'release' ||
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) ||
      (github.event_name == 'workflow_dispatch' &&
        (github.event.inputs.platforms == 'all' || github.event.inputs.platforms == 'macos' || github.event.inputs.platforms == ''))
    strategy:
      matrix:
        client: [employee, admin]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pyenv
        run: |
          echo "安装 pyenv..."
          # 安装 pyenv 依赖
          brew install openssl readline sqlite3 xz zlib tcl-tk || true
          # 安装 pyenv
          curl https://pyenv.run | bash || {
            # 如果 curl 失败，尝试使用 git clone
            git clone https://github.com/pyenv/pyenv.git ~/.pyenv || true
          }
          # 设置 pyenv 环境变量（用于后续步骤）
          export PYENV_ROOT="$HOME/.pyenv"
          export PATH="$PYENV_ROOT/bin:$PATH"
          echo "PYENV_ROOT=$PYENV_ROOT" >> $GITHUB_ENV
          echo "PATH=$PYENV_ROOT/bin:$PATH" >> $GITHUB_ENV
          # 验证 pyenv 安装
          "$PYENV_ROOT/bin/pyenv" --version || echo "警告: pyenv 安装可能失败"
      
      - name: Install Python 3.10.4 with pyenv
        run: |
          export PYENV_ROOT="${{ env.PYENV_ROOT || '$HOME/.pyenv' }}"
          export PATH="$PYENV_ROOT/bin:$PATH"
          eval "$(pyenv init - bash)"
          echo "使用 pyenv 安装 Python 3.10.4..."
          # 设置部署目标为 10.13，确保向后兼容性
          # 问题分析：
          # - 之前没有设置 MACOSX_DEPLOYMENT_TARGET，Python 使用了默认值（14.7）
          # - 导致 Python 库链接了 macOS 13+ 的符号（如 _mkfifoat）
          # - _mkfifoat 符号在 macOS 13.0+ 才可用，在 macOS 12.7.6 上会找不到
          # 解决方案：
          # - 在编译 Python 时设置 MACOSX_DEPLOYMENT_TARGET=10.13
          # - 编译器会检查符号可用性，避免使用 macOS 13+ 的符号
          # - 这样既能支持 macOS 10.13+，又能确保在 macOS 12.7.6 上运行
          export MACOSX_DEPLOYMENT_TARGET=10.13
          export CFLAGS="-mmacosx-version-min=10.13"
          export LDFLAGS="-mmacosx-version-min=10.13"
          export CPPFLAGS="-mmacosx-version-min=10.13"
          # 确保编译器遵守部署目标，避免使用新版本符号
          export CC="clang -mmacosx-version-min=10.13"
          export CXX="clang++ -mmacosx-version-min=10.13"
          echo "设置部署目标: MACOSX_DEPLOYMENT_TARGET=10.13 (支持 macOS 10.13+，避免使用 macOS 13+ 符号)"
          # 安装 Python 3.10.4（这可能需要几分钟）
          pyenv install -s 3.10.4 || {
            echo "警告: Python 3.10.4 安装失败，尝试继续..."
            # 如果安装失败，尝试使用系统 Python
            if [ -f "/Library/Frameworks/Python.framework/Versions/3.10/bin/python3" ]; then
              echo "使用系统 Python 3.10"
              echo "PYTHON_CMD=/Library/Frameworks/Python.framework/Versions/3.10/bin/python3" >> $GITHUB_ENV
            else
              echo "错误: 无法安装或找到 Python 3.10.4"
              exit 1
            fi
          }
          # 设置全局 Python 版本为 3.10.4
          pyenv global 3.10.4 || echo "警告: 无法设置全局 Python 版本"
          # 验证 Python 版本
          pyenv version
          python3 --version
          # 将 Python 路径添加到环境变量
          PYTHON_CMD=$(pyenv which python3)
          echo "Python 路径: $PYTHON_CMD"
          echo "PYTHON_CMD=$PYTHON_CMD" >> $GITHUB_ENV
      
      - name: Install dependencies
        env:
          MACOSX_DEPLOYMENT_TARGET: '10.13'
        run: |
          # 使用 pyenv 的 Python（如果已安装）
          if [ -n "${{ env.PYTHON_CMD }}" ] && [ -f "${{ env.PYTHON_CMD }}" ]; then
            PYTHON="${{ env.PYTHON_CMD }}"
            echo "使用 pyenv Python: $PYTHON"
            # pyenv Python 不需要 --break-system-packages 选项
            "$PYTHON" -m pip install --upgrade pip
            "$PYTHON" -m pip install -r requirements.txt
          else
            # 回退到系统 Python（需要 --break-system-packages）
            export PYENV_ROOT="${{ env.PYENV_ROOT || '$HOME/.pyenv' }}"
            export PATH="$PYENV_ROOT/bin:$PATH"
            eval "$(pyenv init - bash)" || true
            python3 -m pip install --upgrade pip --break-system-packages
            pip3 install -r requirements.txt --break-system-packages
          fi
      
      - name: Verify PyInstaller installation
        run: |
          # 使用 pyenv 的 Python（如果已安装）
          if [ -n "${{ env.PYTHON_CMD }}" ] && [ -f "${{ env.PYTHON_CMD }}" ]; then
            PYTHON="${{ env.PYTHON_CMD }}"
          else
            export PYENV_ROOT="${{ env.PYENV_ROOT || '$HOME/.pyenv' }}"
            export PATH="$PYENV_ROOT/bin:$PATH"
            eval "$(pyenv init - bash)" || true
            PYTHON="python3"
          fi
          echo "验证 PyInstaller 安装..."
          "$PYTHON" -m PyInstaller --version || echo "警告: PyInstaller 未正确安装"
          "$PYTHON" -m pip list | grep -i pyinstaller || echo "警告: 未找到 PyInstaller 包"
      
      - name: Check if should build
        id: check_build
        run: |
          if [ "${{ github.event_name }}" == "release" ] || \
             [ "${{ github.event_name }}" == "push" ] || \
             [ "${{ github.event.inputs.client_type }}" == "both" ] || \
             [ "${{ github.event.inputs.client_type }}" == "${{ matrix.client }}" ] || \
             [ "${{ github.event.inputs.client_type }}" == "" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Print environment diagnostics
        if: steps.check_build.outputs.should_build == 'true'
        run: |
          # 使用 pyenv 的 Python（如果已安装）
          if [ -n "${{ env.PYTHON_CMD }}" ] && [ -f "${{ env.PYTHON_CMD }}" ]; then
            PYTHON="${{ env.PYTHON_CMD }}"
          else
            export PYENV_ROOT="${{ env.PYENV_ROOT || '$HOME/.pyenv' }}"
            export PATH="$PYENV_ROOT/bin:$PATH"
            eval "$(pyenv init - bash)" || true
            PYTHON="python3"
          fi
          echo "========================================"
          echo "GitHub Actions 环境诊断信息 (Intel)"
          echo "========================================"
          echo "Python 版本:"
          "$PYTHON" --version
          echo "Python 路径:"
          which "$PYTHON" || echo "$PYTHON"
          echo "PyInstaller 版本:"
          "$PYTHON" -m PyInstaller --version || echo "未安装"
          echo "操作系统信息:"
          sw_vers
          echo "系统版本:"
          uname -a
          echo "文件系统信息:"
          df -T $(pwd) || df $(pwd)
          echo "挂载信息:"
          mount | grep -E "$(df $(pwd) | tail -1 | awk '{print $1}')" || mount | head -5
          echo "环境变量:"
          echo "  MACOSX_DEPLOYMENT_TARGET = ${MACOSX_DEPLOYMENT_TARGET:-未设置}"
          echo "  TMPDIR = ${TMPDIR:-未设置}"
          echo "  HOME = ${HOME:-未设置}"
          echo "  PWD = $(pwd)"
          echo "工作目录路径长度:"
          echo $(pwd) | wc -c
          echo "测试符号链接创建:"
          mkdir -p .symlink_test
          echo "test" > .symlink_test/test_file.txt
          if ln -s test_file.txt .symlink_test/test_link 2>&1; then
            echo "  ✓ 可以创建符号链接"
            ls -la .symlink_test/
          else
            echo "  ✗ 无法创建符号链接"
          fi
          rm -rf .symlink_test
          echo "========================================"
      
      - name: Import Apple Certificate
        if: steps.check_build.outputs.should_build == 'true'
        env:
          APPLICATION_P12_BASE64: ${{ secrets.APPLICATION_P12_BASE64 }}
          APPLICATION_P12_PASSWORD: ${{ secrets.APPLICATION_P12_PASSWORD }}
          INSTALLER_P12_BASE64: ${{ secrets.INSTALLER_P12_BASE64 }}
          INSTALLER_P12_PASSWORD: ${{ secrets.INSTALLER_P12_PASSWORD }}
        run: |
          # 创建临时 keychain 用于签名
          KEYCHAIN_NAME="build.keychain"
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          
          # 创建 keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_NAME"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          
          # 获取 keychain 的完整路径（macOS 可能使用 -db 后缀）
          KEYCHAIN_PATH="$HOME/Library/Keychains/${KEYCHAIN_NAME}-db"
          if [ ! -f "$KEYCHAIN_PATH" ]; then
            KEYCHAIN_PATH="$HOME/Library/Keychains/${KEYCHAIN_NAME}"
          fi
          
          # 设置 keychain 为默认（使用 -d user 确保在用户域中）
          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"
          
          # 导入 Application 证书（如果提供）
          if [ -n "$APPLICATION_P12_BASE64" ]; then
            echo "导入 Developer ID Application 证书..."
            echo "$APPLICATION_P12_BASE64" | base64 --decode > /tmp/application.p12
            if [ -n "$APPLICATION_P12_PASSWORD" ]; then
              security import /tmp/application.p12 -k "$KEYCHAIN_PATH" -P "$APPLICATION_P12_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/productsign || true
            else
              security import /tmp/application.p12 -k "$KEYCHAIN_PATH" -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/productsign || true
            fi
            rm -f /tmp/application.p12
          fi
          
          # 导入 Installer 证书（如果提供）
          if [ -n "$INSTALLER_P12_BASE64" ]; then
            echo "导入 Developer ID Installer 证书..."
            echo "$INSTALLER_P12_BASE64" | base64 --decode > /tmp/installer.p12
            
            # 验证 p12 文件内容（检查是否包含 Installer 证书）
            echo "验证 p12 文件内容..."
            if [ -n "$INSTALLER_P12_PASSWORD" ]; then
              # 尝试从 p12 中提取证书信息
              openssl pkcs12 -in /tmp/installer.p12 -passin pass:"$INSTALLER_P12_PASSWORD" -nokeys -clcerts 2>/dev/null | openssl x509 -noout -subject -issuer 2>/dev/null || echo "无法读取 p12 文件内容（可能需要密码）"
              
              IMPORT_RESULT=$(security import /tmp/installer.p12 -k "$KEYCHAIN_PATH" -P "$INSTALLER_P12_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/productsign 2>&1)
              IMPORT_EXIT_CODE=$?
            else
              IMPORT_RESULT=$(security import /tmp/installer.p12 -k "$KEYCHAIN_PATH" -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/productsign 2>&1)
              IMPORT_EXIT_CODE=$?
            fi
            
            if [ $IMPORT_EXIT_CODE -eq 0 ]; then
              echo "✓ Installer p12 证书导入成功"
              
              # 立即设置 keychain 访问权限（确保 productsign 可以访问）
              echo "设置 Installer 证书的 keychain 访问权限..."
              security set-key-partition-list -S apple-tool:,apple:,codesign:,productsign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH" || true
              
              # 将 keychain 添加到搜索列表（确保证书可以被找到）
              security list-keychains -d user -s "$KEYCHAIN_PATH" || true
              
              # 等待一下，确保证书被索引
              sleep 1
            else
              echo "✗ Installer p12 证书导入失败（退出码: $IMPORT_EXIT_CODE）"
              echo "错误信息: $IMPORT_RESULT"
              echo "可能的原因："
              echo "  1. p12 文件密码错误"
              echo "  2. p12 文件损坏或不完整"
              echo "  3. p12 文件不包含 Installer 证书（可能是 Application 证书）"
              # 不立即退出，让后续步骤显示更详细的错误
            fi
            rm -f /tmp/installer.p12
          else
            echo "⚠ 未提供 INSTALLER_P12_BASE64，跳过 Installer 证书导入"
          fi
          
          # 允许 codesign 和 productsign 访问 keychain（对所有证书）
          echo "设置所有证书的 keychain 访问权限..."
          security set-key-partition-list -S apple-tool:,apple:,codesign:,productsign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH" || true
          
          # 列出可用的签名身份
          echo "可用的签名身份:"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true
          
          # 保存 keychain 信息到环境变量（用于后续步骤）
          echo "KEYCHAIN_NAME=$KEYCHAIN_NAME" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
      
      - name: Build client (Intel)
        if: steps.check_build.outputs.should_build == 'true'
        env:
          MACOSX_DEPLOYMENT_TARGET: '10.13'
          CFLAGS: '-mmacosx-version-min=10.13'
          LDFLAGS: '-mmacosx-version-min=10.13'
          CPPFLAGS: '-mmacosx-version-min=10.13'
          PYTHONUNBUFFERED: '1'  # 确保 Python 输出无缓冲，实时显示日志
          # 不设置 SKIP_SIGNING，执行完整的签名和公证流程
          GOOGLE_CLIENT_SECRET_JSON: ${{ secrets.GOOGLE_CLIENT_SECRET_JSON }}
          CODESIGN_IDENTITY: ${{ secrets.CODESIGN_IDENTITY }}
          INSTALLER_CODESIGN_IDENTITY: ${{ secrets.INSTALLER_CODESIGN_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          TEAM_ID: ${{ secrets.TEAM_ID }}
          NOTARY_PASSWORD: ${{ secrets.NOTARY_PASSWORD }}
        run: |
          # 确保 keychain 可访问（仅在 GitHub Actions 环境中）
          if [ -n "$KEYCHAIN_NAME" ] && [ -n "$KEYCHAIN_PASSWORD" ]; then
            echo "确保 keychain 可访问..."
            # 获取 keychain 的完整路径
            if [ -n "$KEYCHAIN_PATH" ]; then
              KEYCHAIN_FULL_PATH="$KEYCHAIN_PATH"
            else
              KEYCHAIN_FULL_PATH="$HOME/Library/Keychains/${KEYCHAIN_NAME}-db"
              if [ ! -f "$KEYCHAIN_FULL_PATH" ]; then
                KEYCHAIN_FULL_PATH="$HOME/Library/Keychains/${KEYCHAIN_NAME}"
              fi
            fi
            
            # 将 keychain 添加到搜索列表（使用 -d user 确保是用户域）
            security list-keychains -d user -s "$KEYCHAIN_FULL_PATH" || true
            
            # 重新解锁 keychain
            security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_FULL_PATH" || true
            
            # 设置 keychain 为默认
            security default-keychain -s "$KEYCHAIN_FULL_PATH" || true
            
            # 验证证书是否可用
            echo "验证证书是否可用..."
            security find-identity -v -p codesigning "$KEYCHAIN_FULL_PATH" || {
              echo "⚠ 警告: 在指定 keychain 中查找证书失败，尝试在所有 keychain 中查找..."
              security find-identity -v -p codesigning || true
            }
            
            # 确保 productsign 可以访问 keychain
            security set-key-partition-list -S apple-tool:,apple:,codesign:,productsign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_FULL_PATH" || true
          fi
          
          # 使用 pyenv 的 Python（如果已安装）
          if [ -n "${{ env.PYTHON_CMD }}" ] && [ -f "${{ env.PYTHON_CMD }}" ]; then
            PYTHON="${{ env.PYTHON_CMD }}"
          else
            export PYENV_ROOT="${{ env.PYENV_ROOT || '$HOME/.pyenv' }}"
            export PATH="$PYENV_ROOT/bin:$PATH"
            eval "$(pyenv init - bash)" || true
            PYTHON="python3"
          fi
          cd ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}
          "$PYTHON" ../scripts/build_client.py ${{ matrix.client }} macos
      
      - name: Verify deployment target
        if: steps.check_build.outputs.should_build == 'true'
        run: |
          cd ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}
          # 查找打包后的 .app 文件
          APP_BUNDLE=$(find dist -name "*.app" -type d | head -1)
          if [ -z "$APP_BUNDLE" ]; then
            echo "⚠ 未找到 .app 文件，跳过验证"
            exit 0
          fi
          echo "========================================"
          echo "验证部署目标: $APP_BUNDLE"
          echo "========================================"
          # 检查 Python 库的部署目标
          PYTHON_LIB="$APP_BUNDLE/Contents/Resources/libpython3.10.dylib"
          if [ -f "$PYTHON_LIB" ]; then
            echo "检查 Python 库部署目标:"
            BUILD_VERSION=$(otool -l "$PYTHON_LIB" 2>/dev/null | grep -A 5 "LC_BUILD_VERSION" | grep "minos" || echo "")
            if [ -n "$BUILD_VERSION" ]; then
              echo "  $BUILD_VERSION"
              if echo "$BUILD_VERSION" | grep -q "minos 1[0-1]\."; then
                echo "  ✓ 部署目标正确（macOS 10.x 或 11.x）"
              elif echo "$BUILD_VERSION" | grep -q "minos 12\."; then
                echo "  ✓ 部署目标正确（macOS 12.x）"
              else
                echo "  ⚠ 警告: 部署目标可能过高"
              fi
            else
              echo "  ⚠ 未找到构建版本信息"
            fi
            echo "检查是否引用 macOS 13+ 符号 (_mkfifoat):"
            if nm -u "$PYTHON_LIB" 2>/dev/null | grep -q "_mkfifoat"; then
              echo "  ⚠ 警告: Python 库仍引用 _mkfifoat 符号（macOS 13+）"
              echo "  这可能导致在 macOS 12.7.6 上运行时出错"
            else
              echo "  ✓ Python 库未引用 _mkfifoat 符号"
            fi
          else
            echo "⚠ 未找到 Python 库，跳过验证"
          fi
          echo "========================================"
      
      - name: Fix executable permissions
        if: steps.check_build.outputs.should_build == 'true'
        run: |
          cd ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}
          # 修复 .app 包中主可执行文件的权限（GitHub Actions 打包的文件可能没有执行权限）
          find dist -name "*.app" -type d | while read app_bundle; do
            app_name=$(basename "$app_bundle" .app)
            executable="$app_bundle/Contents/MacOS/$app_name"
            if [ -f "$executable" ]; then
              chmod +x "$executable"
              echo "✓ 修复权限: $executable"
            fi
          done
      
      - name: Cleanup keychain
        if: always() && steps.check_build.outputs.should_build == 'true'
        run: |
          if [ -n "$KEYCHAIN_NAME" ]; then
            security delete-keychain "$KEYCHAIN_NAME" || true
            security list-keychains -d user | grep -v "$KEYCHAIN_NAME" | xargs security list-keychains -d user -s || true
          fi
      
      - name: Upload APP artifact
        if: steps.check_build.outputs.should_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.client }}-macos-intel-app
          path: ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}/dist/intel/*.app
          retention-days: 30

  build-windows:
    name: Build Windows
    runs-on: windows-latest
    timeout-minutes: 120  # 2小时超时
    if: >
      github.event_name == 'release' ||
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) ||
      (github.event_name == 'workflow_dispatch' &&
        (github.event.inputs.platforms == 'all' || github.event.inputs.platforms == 'windows' || github.event.inputs.platforms == ''))
    strategy:
      matrix:
        client: [employee, admin]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          architecture: 'x64'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          # Windows 上通常不需要 --break-system-packages，但为了保险起见，如果遇到错误可以添加
      
      - name: Verify PyInstaller installation
        run: |
          echo "验证 PyInstaller 安装..."
          python -m PyInstaller --version || echo "警告: PyInstaller 未正确安装"
          pip list | findstr /i pyinstaller || echo "警告: 未找到 PyInstaller 包"
      
      - name: Install Inno Setup
        run: |
          choco install innosetup -y
        continue-on-error: true
      
      - name: Install WiX Toolset
        run: |
          # WiX Toolset 6.0 需要从 GitHub releases 下载 MSI 安装包
          Write-Host "正在下载 WiX Toolset 6.0..."
          
          $wixVersion = "6.0.0"
          # WiX Toolset 6.0 MSI 安装包下载地址
          $wixUrl = "https://github.com/wixtoolset/wix4/releases/download/v$wixVersion/wix-cli-x64.msi"
          $wixInstaller = "$env:TEMP\wix$wixVersion.msi"
          
          try {
            Invoke-WebRequest -Uri $wixUrl -OutFile $wixInstaller -ErrorAction Stop
            Write-Host "下载完成，正在安装..."
            
            # 静默安装 WiX Toolset
            Start-Process -FilePath "msiexec.exe" -ArgumentList "/i `"$wixInstaller`" /quiet /norestart" -Wait -NoNewWindow
            
            # 等待安装完成并刷新环境变量
            Start-Sleep -Seconds 5
            $env:PATH = [System.Environment]::GetEnvironmentVariable("PATH", "Machine") + ";" + [System.Environment]::GetEnvironmentVariable("PATH", "User")
            
            # 验证安装（检查常见安装路径）
            $wixPaths = @(
              "${env:ProgramFiles}\WiX Toolset v$wixVersion\bin",
              "${env:ProgramFiles(x86)}\WiX Toolset v$wixVersion\bin",
              "${env:ProgramFiles}\WiX Toolset v6.0\bin",
              "${env:ProgramFiles(x86)}\WiX Toolset v6.0\bin"
            )
            
            $wixFound = $false
            foreach ($path in $wixPaths) {
              if (Test-Path "$path\wix.exe") {
                $env:PATH = "$path;$env:PATH"
                Write-Host "✓ WiX Toolset 已安装到: $path"
                & "$path\wix.exe" --version
                $wixFound = $true
                break
              }
            }
            
            if (-not $wixFound) {
              Write-Host "⚠ WiX Toolset 可能未正确安装到预期路径"
            }
          } catch {
            Write-Host "下载或安装失败: $_"
            Write-Host "将尝试使用 Chocolatey 安装..."
            choco install wixtoolset -y
          } finally {
            # 清理安装包
            if (Test-Path $wixInstaller) {
              Remove-Item $wixInstaller -Force
            }
          }
        continue-on-error: true
      
      - name: Check if should build
        id: check_build
        shell: bash
        run: |
          if [ "${{ github.event_name }}" == "release" ] || \
             [ "${{ github.event_name }}" == "push" ] || \
             [ "${{ github.event.inputs.client_type }}" == "both" ] || \
             [ "${{ github.event.inputs.client_type }}" == "${{ matrix.client }}" ] || \
             [ "${{ github.event.inputs.client_type }}" == "" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Build client (Windows)
        if: steps.check_build.outputs.should_build == 'true'
        env:
          PYTHONUNBUFFERED: '1'  # 确保 Python 输出无缓冲，实时显示日志
          GOOGLE_CLIENT_SECRET_JSON: ${{ secrets.GOOGLE_CLIENT_SECRET_JSON }}
        run: |
          cd ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}
          python ../scripts/build_client.py ${{ matrix.client }} windows
      
      - name: Upload EXE artifact (Setup installer)
        if: steps.check_build.outputs.should_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.client }}-windows-exe
          path: ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}/dist/*_Setup.exe
          retention-days: 30
          if-no-files-found: ignore
      
      - name: Upload EXE artifact (fallback to raw EXE if no Setup)
        if: steps.check_build.outputs.should_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.client }}-windows-exe-raw
          path: ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}/dist/*.exe
          retention-days: 30
          if-no-files-found: ignore
      
      - name: Upload MSI artifact
        if: steps.check_build.outputs.should_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.client }}-windows-msi
          path: ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}/dist/*.msi
          retention-days: 30
          if-no-files-found: ignore

  build-linux-ubuntu:
    name: Build Linux (Ubuntu/Debian)
    runs-on: ubuntu-22.04
    timeout-minutes: 120  # 2小时超时
    if: >
      github.event_name == 'release' ||
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) ||
      (github.event_name == 'workflow_dispatch' &&
        (github.event.inputs.platforms == 'all' || github.event.inputs.platforms == 'linux' || github.event.inputs.platforms == ''))
    strategy:
      matrix:
        client: [employee, admin]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Install system dependencies
        run: |
          sudo apt-get update
          # 安装 DEB 打包工具
          sudo apt-get install -y \
            dpkg-dev \
            fakeroot \
            build-essential \
            libgl1-mesa-glx \
            libxkbcommon-x11-0 \
            libxcb-xinerama0 \
            libxcb-cursor0
          # 安装 RPM 打包工具（rpmbuild 包含在 rpm 包中）
          # 在 Ubuntu 上，rpm 包提供了 rpmbuild 工具
          sudo apt-get install -y rpm || echo "警告: rpm 包安装失败，RPM 打包将不可用"
          # 验证 rpmbuild 是否可用
          which rpmbuild || echo "警告: rpmbuild 未找到，RPM 打包将不可用"
      
      - name: Install Python dependencies
        run: |
          python3 -m pip install --upgrade pip --break-system-packages
          pip3 install -r requirements.txt --break-system-packages
      
      - name: Verify PyInstaller installation
        run: |
          echo "验证 PyInstaller 安装..."
          python3 -m PyInstaller --version || echo "警告: PyInstaller 未正确安装"
          pip3 list | grep -i pyinstaller || echo "警告: 未找到 PyInstaller 包"
      
      - name: Check if should build
        id: check_build
        run: |
          if [ "${{ github.event_name }}" == "release" ] || \
             [ "${{ github.event_name }}" == "push" ] || \
             [ "${{ github.event.inputs.client_type }}" == "both" ] || \
             [ "${{ github.event.inputs.client_type }}" == "${{ matrix.client }}" ] || \
             [ "${{ github.event.inputs.client_type }}" == "" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi

      - name: Build client (Linux)
        if: steps.check_build.outputs.should_build == 'true'
        env:
          PYTHONUNBUFFERED: '1'  # 确保 Python 输出无缓冲，实时显示日志
          GOOGLE_CLIENT_SECRET_JSON: ${{ secrets.GOOGLE_CLIENT_SECRET_JSON }}
        run: |
          cd ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}
          python3 ../scripts/build_client.py ${{ matrix.client }} linux
      
      - name: Upload DEB artifact
        if: steps.check_build.outputs.should_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.client }}-linux-deb
          path: ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}/dist/*.deb
          retention-days: 30
          if-no-files-found: ignore
      
      - name: Upload RPM artifact
        if: steps.check_build.outputs.should_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.client }}-linux-rpm
          path: ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}/dist/*.rpm
          retention-days: 30
          if-no-files-found: ignore

  create-release:
    name: Create Release
    needs: [build-macos-arm64, build-macos-intel, build-windows, build-linux-ubuntu]
    runs-on: ubuntu-latest
    # 在 release 事件或 push tag 事件时创建 Release（手动触发时不创建）
    if: github.event_name == 'release' || (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v'))
    permissions:
      contents: write
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      
      - name: Determine tag name
        id: tag_name
        run: |
          if [ "${{ github.event_name }}" == "release" ]; then
            echo "tag=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "push" ]; then
            # 从 refs/tags/v1.0.0 提取 v1.0.0
            TAG_NAME=${GITHUB_REF#refs/tags/}
            echo "tag=${TAG_NAME}" >> $GITHUB_OUTPUT
          fi
      
      - name: Filter release files
        run: |
          # 创建 release_files 目录
          mkdir -p release_files
          
          # 复制 .app 目录并打包成 ZIP（macOS 应用包是目录，需要打包）
          # 只保留主应用，过滤掉 QtWebEngineProcess.app 等辅助应用
          # 根据 artifact 目录名判断架构（格式：{client}-macos-{arch}-app）
          find artifacts -type d -name "*.app" | while read app_path; do
            app_name=$(basename "$app_path")
            # 过滤掉 QtWebEngineProcess.app 等辅助应用
            if [[ "$app_name" != "QtWebEngineProcess.app" ]]; then
              # 从完整路径中提取 artifact 目录名
              # 路径格式：artifacts/{client}-macos-{arch}-app/.../{app_name}.app
              arch="unknown"
              
              # 方法1: 从 artifact 目录名提取（优先级最高）
              # 查找路径中的 artifact 目录（包含 -macos- 的目录）
              # 使用 sed 替代 grep -oE，避免兼容性问题
              artifact_dir=$(echo "$app_path" | sed -n 's|.*\(artifacts/[^/]*-macos-[^/]*-app\).*|\1|p' | head -n 1)
              if [[ -n "$artifact_dir" ]]; then
                # 提取架构部分：{client}-macos-{arch}-app
                artifact_name=$(basename "$artifact_dir")
                if echo "$artifact_name" | grep -qE "-macos-arm64-app$"; then
                  arch="arm64"
                elif echo "$artifact_name" | grep -qE "-macos-intel-app$"; then
                  arch="intel"
                fi
              fi
              
              # 方法2: 如果方法1失败，尝试从路径中查找架构目录
              if [[ "$arch" == "unknown" ]]; then
                if echo "$app_path" | grep -qE "/(arm64|m)/"; then
                  arch="arm64"
                elif echo "$app_path" | grep -q "/intel/"; then
                  arch="intel"
                fi
              fi
              
              # 生成带架构信息的 ZIP 文件名
              # 如果架构未知，尝试从路径中提取更多信息
              if [[ "$arch" == "unknown" ]]; then
                # 尝试从完整路径中提取更多信息
                if echo "$app_path" | grep -q "employee-macos-arm64-app"; then
                  arch="arm64"
                elif echo "$app_path" | grep -q "employee-macos-intel-app"; then
                  arch="intel"
                elif echo "$app_path" | grep -q "admin-macos-arm64-app"; then
                  arch="arm64"
                elif echo "$app_path" | grep -q "admin-macos-intel-app"; then
                  arch="intel"
                fi
              fi
              
              # 生成 ZIP 文件名（确保唯一性）
              if [[ "$arch" != "unknown" ]]; then
                zip_name="${app_name}-${arch}.zip"
              else
                # 如果架构仍然未知，使用路径中的信息生成唯一文件名
                # 从路径中提取客户端类型和可能的架构
                if echo "$app_path" | grep -q "employee"; then
                  client_suffix="employee"
                elif echo "$app_path" | grep -q "admin"; then
                  client_suffix="admin"
                else
                  client_suffix="unknown"
                fi
                zip_name="${app_name}-${client_suffix}.zip"
                echo "⚠ 警告: 无法确定架构，使用 ${client_suffix} 作为后缀"
              fi
              
              echo "打包 $app_name ($arch) -> $zip_name..."
              echo "  路径: $app_path"
              
              # 检查是否已存在同名文件（避免覆盖）
              if [[ -f "release_files/${zip_name}" ]]; then
                echo "⚠ 警告: ${zip_name} 已存在，生成唯一文件名..."
                # 从路径中提取更多信息生成唯一文件名
                if echo "$app_path" | grep -q "employee-macos-arm64-app"; then
                  zip_name="${app_name}-employee-arm64.zip"
                elif echo "$app_path" | grep -q "employee-macos-intel-app"; then
                  zip_name="${app_name}-employee-intel.zip"
                elif echo "$app_path" | grep -q "admin-macos-arm64-app"; then
                  zip_name="${app_name}-admin-arm64.zip"
                elif echo "$app_path" | grep -q "admin-macos-intel-app"; then
                  zip_name="${app_name}-admin-intel.zip"
                else
                  # 使用时间戳确保唯一性
                  zip_name="${app_name}-$(date +%s).zip"
                fi
                echo "  使用唯一文件名: $zip_name"
              fi
              
              # 使用最高压缩级别（-9）和排除不必要的文件
              zip -r -9 "release_files/${zip_name}" "$app_path" -q \
                -x "*.DS_Store" \
                -x "*__pycache__*" \
                -x "*.pyc" \
                -x "*.pyo" \
                -x "*.pyd" \
                -x ".git/*" \
                -x ".gitignore" \
                -x "*.log" \
                -x "*.tmp" \
                -x "*.bak"
              
              # 检查文件大小（GitHub 限制 2 GB = 2147483648 字节）
              if command -v stat >/dev/null 2>&1; then
                # macOS 使用 stat -f%z，Linux 使用 stat -c%s
                file_size=$(stat -f%z "release_files/${zip_name}" 2>/dev/null || stat -c%s "release_files/${zip_name}" 2>/dev/null || echo "0")
                file_size_mb=$(echo "scale=2; $file_size / 1048576" | bc 2>/dev/null || awk "BEGIN {printf \"%.2f\", $file_size / 1048576}")
                
                # 检查是否超过 2 GB（2147483648 字节）
                if [ "$file_size" -gt 2147483648 ] 2>/dev/null; then
                  echo "⚠ 警告: $zip_name 大小 ${file_size_mb} MB (${file_size} 字节)，超过 GitHub 2 GB 限制，将跳过上传"
                  rm -f "release_files/${zip_name}"
                else
                  echo "✓ $zip_name 大小: ${file_size_mb} MB"
                fi
              else
                echo "⚠ 无法检查文件大小，继续上传 $zip_name"
              fi
            fi
          done
          
          # 复制安装包文件（.dmg, .pkg, .exe, .msi, .deb, .rpm）
          # 优先复制安装器 EXE（*_Setup.exe），如果存在则排除原始 EXE
          find artifacts -type f \( \
            -name "*.dmg" -o \
            -name "*.pkg" -o \
            -name "*.msi" -o \
            -name "*.deb" -o \
            -name "*.rpm" \
          \) -exec cp {} release_files/ \;
          
          # 优先复制安装器 EXE（*_Setup.exe）
          find artifacts -type f -name "*_Setup.exe" -exec cp {} release_files/ \;
          
          # 如果没有找到安装器，则复制原始 EXE（作为后备）
          if [ -z "$(find release_files -name "*_Setup.exe" 2>/dev/null)" ]; then
            echo "⚠ 未找到安装器 EXE，使用原始 EXE 作为后备"
            find artifacts -type f -name "*.exe" ! -name "*_Setup.exe" -exec cp {} release_files/ \;
          else
            echo "✓ 已找到安装器 EXE，跳过原始 EXE"
          fi
          
          # 显示要上传的文件
          echo ""
          echo "准备上传的文件："
          ls -lh release_files/ || echo "未找到安装包文件"
          
          # 检查是否有文件超过 2 GB
          echo ""
          echo "文件大小检查："
          for file in release_files/*; do
            if [ -f "$file" ]; then
              file_name=$(basename "$file")
              # macOS 使用 stat -f%z，Linux 使用 stat -c%s
              file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
              file_size_mb=$(echo "scale=2; $file_size / 1048576" | bc 2>/dev/null || awk "BEGIN {printf \"%.2f\", $file_size / 1048576}")
              
              # 检查是否超过 2 GB（2147483648 字节）
              if [ "$file_size" -gt 2147483648 ] 2>/dev/null; then
                echo "✗ $file_name: ${file_size_mb} MB (超过 2 GB 限制，将被跳过)"
                rm -f "$file"
              else
                echo "✓ $file_name: ${file_size_mb} MB"
              fi
            fi
          done
      
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.tag_name.outputs.tag }}
          name: Release ${{ steps.tag_name.outputs.tag }}
          files: release_files/*
          draft: false
          prerelease: false
          fail_on_unmatched_files: false  # 如果没有文件也不失败
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
