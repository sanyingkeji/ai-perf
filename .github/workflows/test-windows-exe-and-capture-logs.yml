# 测试 Windows EXE 并抓取日志
# 
# 注意：GitHub Actions 的 Windows runner 都是服务器版本（Windows Server），
# 不是桌面版的 Windows 11。使用 windows-2022 runner 作为最接近 Windows 11 的环境。
# 如需在真实的 Windows 11 桌面版上测试，建议使用自托管的 runner。

name: 测试 Windows EXE 并抓取日志

on:
  workflow_dispatch:
    inputs:
      exe_url:
        description: 'EXE 文件下载 URL'
        required: true
        type: string
        default: ''
      wait_seconds:
        description: '等待时间（秒）'
        required: false
        type: number
        default: 30
      check_interval:
        description: '进程检查间隔（秒）'
        required: false
        type: number
        default: 2

jobs:
  test-and-capture-logs:
    name: 测试 EXE 并抓取日志（Windows 11）
    runs-on: windows-2022  # Windows Server 2022，最接近 Windows 11 的环境
    timeout-minutes: 10

    steps:
      - name: 检查输入参数
        run: |
          echo "EXE URL: ${{ github.event.inputs.exe_url }}"
          echo "等待时间: ${{ github.event.inputs.wait_seconds }}秒"
          echo "检查间隔: ${{ github.event.inputs.check_interval }}秒"

      - name: 创建测试目录
        run: |
          $testDir = "C:\test-ai-perf"
          if (Test-Path $testDir) {
            Remove-Item -Recurse -Force $testDir
          }
          New-Item -ItemType Directory -Path $testDir -Force | Out-Null
          echo "TEST_DIR=$testDir" >> $env:GITHUB_ENV

      - name: 下载 EXE 文件
        run: |
          $exeUrl = "${{ github.event.inputs.exe_url }}"
          $exePath = "$env:TEST_DIR\AiPerfClient.exe"

          Write-Host "正在下载: $exeUrl"
          Write-Host "保存到: $exePath"

          # 下载文件
          Invoke-WebRequest -Uri $exeUrl -OutFile $exePath -UseBasicParsing

          if (Test-Path $exePath) {
            $fileSize = (Get-Item $exePath).Length
            Write-Host "下载成功，文件大小: $fileSize 字节"
            echo "EXE_PATH=$exePath" >> $env:GITHUB_ENV
          } else {
            Write-Host "下载失败！"
            exit 1
          }

      - name: 清理旧配置和日志
        run: |
          $configDir = "$env:APPDATA\ai-perf"
          $logDir = "$configDir\logs"

          Write-Host "清理旧配置和日志..."
          if (Test-Path $configDir) {
            Remove-Item -Recurse -Force $configDir
            Write-Host "已删除: $configDir"
          }

          # 确保目录存在
          New-Item -ItemType Directory -Path $logDir -Force | Out-Null
          Write-Host "日志目录: $logDir"
          echo "LOG_DIR=$logDir" >> $env:GITHUB_ENV
          echo "CONFIG_DIR=$configDir" >> $env:GITHUB_ENV

      - name: 清理锁文件
        run: |
          $lockFile = "$env:APPDATA\ai-perf\app_instance.lock"
          if (Test-Path $lockFile) {
            Remove-Item -Force $lockFile
            Write-Host "已删除锁文件: $lockFile"
          }

      - name: 终止可能存在的旧进程
        run: |
          Write-Host "检查是否有旧进程..."
          $processes = Get-Process -Name "Ai Perf Client" -ErrorAction SilentlyContinue
          if ($processes) {
            Write-Host "发现 $($processes.Count) 个旧进程，正在终止..."
            $processes | Stop-Process -Force
            Start-Sleep -Seconds 2
          } else {
            Write-Host "没有发现旧进程"
          }

      - name: 启动应用并监控进程
        id: monitor_process
        run: |
          $exePath = "$env:EXE_PATH"
          $waitSeconds = ${{ github.event.inputs.wait_seconds }}
          $checkInterval = ${{ github.event.inputs.check_interval }}
          $logFile = "$env:TEST_DIR\process_monitor.log"

          Write-Host "启动应用: $exePath"
          Write-Host "监控日志: $logFile"

          # 启动应用
          $process = Start-Process -FilePath $exePath -PassThru -WindowStyle Normal
          $processId = $process.Id
          Write-Host "进程已启动，PID: $processId"
          echo "PROCESS_ID=$processId" >> $env:GITHUB_ENV

          # 记录启动信息
          $startTime = Get-Date
          "=== 进程监控开始 ===" | Out-File -FilePath $logFile -Encoding UTF8
          "启动时间: $startTime" | Out-File -FilePath $logFile -Append -Encoding UTF8
          "进程ID: $processId" | Out-File -FilePath $logFile -Append -Encoding UTF8
          "EXE路径: $exePath" | Out-File -FilePath $logFile -Append -Encoding UTF8
          "" | Out-File -FilePath $logFile -Append -Encoding UTF8

          # 监控进程
          $elapsed = 0
          $processFound = $true

          while ($elapsed -lt $waitSeconds) {
            Start-Sleep -Seconds $checkInterval
            $elapsed += $checkInterval

            # 检查进程是否存在
            $currentProcess = Get-Process -Id $processId -ErrorAction SilentlyContinue
            $processName = "Ai Perf Client"
            $allProcesses = Get-Process -Name $processName -ErrorAction SilentlyContinue

            $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            $status = if ($currentProcess) { "运行中" } else { "已退出" }

            "$timestamp - 经过 $elapsed 秒 - 进程状态: $status (PID: $processId)" | Out-File -FilePath $logFile -Append -Encoding UTF8

            if ($currentProcess) {
              $cpu = $currentProcess.CPU
              $memory = [math]::Round($currentProcess.WorkingSet64 / 1MB, 2)
              "  CPU时间: $cpu 秒, 内存: $memory MB" | Out-File -FilePath $logFile -Append -Encoding UTF8

              # 检查窗口是否可见
              try {
                $mainWindow = $currentProcess.MainWindowHandle
                if ($mainWindow -ne [IntPtr]::Zero) {
                  "  窗口句柄: $mainWindow (可见)" | Out-File -FilePath $logFile -Append -Encoding UTF8
                } else {
                  "  窗口句柄: 无 (可能隐藏)" | Out-File -FilePath $logFile -Append -Encoding UTF8
                }
              } catch {
                "  窗口检查失败: $_" | Out-File -FilePath $logFile -Append -Encoding UTF8
              }
            } else {
              "  进程已退出！" | Out-File -FilePath $logFile -Append -Encoding UTF8
              $processFound = $false

              # 检查退出码
              try {
                $exitCode = $process.ExitCode
                "  退出码: $exitCode" | Out-File -FilePath $logFile -Append -Encoding UTF8
              } catch {
                "  无法获取退出码" | Out-File -FilePath $logFile -Append -Encoding UTF8
              }

              # 检查是否还有其他同名进程
              if ($allProcesses) {
                "  发现其他同名进程: $($allProcesses.Count) 个" | Out-File -FilePath $logFile -Append -Encoding UTF8
                foreach ($p in $allProcesses) {
                  "    PID: $($p.Id), 启动时间: $($p.StartTime)" | Out-File -FilePath $logFile -Append -Encoding UTF8
                }
              }

              break
            }

            # 检查是否有其他同名进程（可能是新启动的实例）
            $otherProcesses = $allProcesses | Where-Object { $_.Id -ne $processId }
            if ($otherProcesses) {
              "  警告: 发现其他同名进程！" | Out-File -FilePath $logFile -Append -Encoding UTF8
              foreach ($p in $otherProcesses) {
                "    PID: $($p.Id), 启动时间: $($p.StartTime)" | Out-File -FilePath $logFile -Append -Encoding UTF8
              }
            }
          }

          $endTime = Get-Date
          $duration = ($endTime - $startTime).TotalSeconds
          "" | Out-File -FilePath $logFile -Append -Encoding UTF8
          "=== 进程监控结束 ===" | Out-File -FilePath $logFile -Append -Encoding UTF8
          "结束时间: $endTime" | Out-File -FilePath $logFile -Append -Encoding UTF8
          "总耗时: $duration 秒" | Out-File -FilePath $logFile -Append -Encoding UTF8
          "最终状态: $(if ($processFound) { '运行中' } else { '已退出' })" | Out-File -FilePath $logFile -Append -Encoding UTF8

          # 如果进程还在运行，尝试获取更多信息
          if ($processFound) {
            $currentProcess = Get-Process -Id $processId -ErrorAction SilentlyContinue
            if ($currentProcess) {
              Write-Host "进程仍在运行，正在收集详细信息..."

              # 获取进程详细信息
              $processInfo = Get-CimInstance Win32_Process -Filter "ProcessId = $processId" | Select-Object *
              "进程详细信息:" | Out-File -FilePath $logFile -Append -Encoding UTF8
              $processInfo | Format-List | Out-File -FilePath $logFile -Append -Encoding UTF8
            }
          }

      - name: 收集日志文件
        if: always()
        run: |
          $logDir = "$env:LOG_DIR"
          $configDir = "$env:CONFIG_DIR"
          $testDir = "$env:TEST_DIR"
          $collectDir = "$env:TEST_DIR\collected_logs"

          New-Item -ItemType Directory -Path $collectDir -Force | Out-Null

          Write-Host "收集日志文件..."

          # 收集应用日志
          if (Test-Path $logDir) {
            Copy-Item -Path "$logDir\*" -Destination $collectDir -Recurse -Force
            Write-Host "已收集应用日志: $logDir"
          } else {
            Write-Host "日志目录不存在: $logDir"
          }

          # 收集配置文件
          if (Test-Path $configDir) {
            Copy-Item -Path "$configDir\*" -Destination "$collectDir\config" -Recurse -Force
            Write-Host "已收集配置文件: $configDir"
          }

          # 收集进程监控日志
          if (Test-Path "$testDir\process_monitor.log") {
            Copy-Item -Path "$testDir\process_monitor.log" -Destination $collectDir -Force
            Write-Host "已收集进程监控日志"
          }

          # 收集 Windows 事件日志（应用相关）
          $eventLogFile = "$collectDir\application_events.log"
          Get-WinEvent -LogName Application -MaxEvents 50 -ErrorAction SilentlyContinue |
            Where-Object { $_.Message -like "*Ai Perf*" -or $_.Message -like "*Python*" } |
            Format-List TimeCreated, Id, LevelDisplayName, Message |
            Out-File -FilePath $eventLogFile -Encoding UTF8

          Write-Host "已收集 Windows 事件日志"

      - name: 收集系统信息
        if: always()
        run: |
          $collectDir = "$env:TEST_DIR\collected_logs"
          $sysInfoFile = "$collectDir\system_info.txt"

          Write-Host "收集系统信息..."

          "=== 系统信息 ===" | Out-File -FilePath $sysInfoFile -Encoding UTF8
          "收集时间: $(Get-Date)" | Out-File -FilePath $sysInfoFile -Append -Encoding UTF8
          "" | Out-File -FilePath $sysInfoFile -Append -Encoding UTF8

          "操作系统:" | Out-File -FilePath $sysInfoFile -Append -Encoding UTF8
          (Get-CimInstance Win32_OperatingSystem | Select-Object Caption, Version, BuildNumber, OSArchitecture) | Format-List | Out-File -FilePath $sysInfoFile -Append -Encoding UTF8

          "" | Out-File -FilePath $sysInfoFile -Append -Encoding UTF8
          "Python 进程:" | Out-File -FilePath $sysInfoFile -Append -Encoding UTF8
          Get-Process python*, pythonw* -ErrorAction SilentlyContinue | Select-Object Id, ProcessName, StartTime, CPU, WorkingSet | Format-Table | Out-File -FilePath $sysInfoFile -Append -Encoding UTF8

          "" | Out-File -FilePath $sysInfoFile -Append -Encoding UTF8
          "所有 Ai Perf 相关进程:" | Out-File -FilePath $sysInfoFile -Append -Encoding UTF8
          Get-Process | Where-Object { $_.ProcessName -like "*Ai*" -or $_.ProcessName -like "*Perf*" } | Select-Object Id, ProcessName, StartTime, CPU, WorkingSet | Format-Table | Out-File -FilePath $sysInfoFile -Append -Encoding UTF8

          "" | Out-File -FilePath $sysInfoFile -Append -Encoding UTF8
          "环境变量:" | Out-File -FilePath $sysInfoFile -Append -Encoding UTF8
          Get-ChildItem Env: | Where-Object { $_.Name -like "*PYTHON*" -or $_.Name -like "*PATH*" } | Format-Table | Out-File -FilePath $sysInfoFile -Append -Encoding UTF8

          Write-Host "系统信息已保存到: $sysInfoFile"

      - name: 检查锁文件状态
        if: always()
        run: |
          $lockFile = "$env:APPDATA\ai-perf\app_instance.lock"
          $collectDir = "$env:TEST_DIR\collected_logs"
          $lockInfoFile = "$collectDir\lock_file_info.txt"

          Write-Host "检查锁文件状态..."

          "=== 锁文件信息 ===" | Out-File -FilePath $lockInfoFile -Encoding UTF8
          "检查时间: $(Get-Date)" | Out-File -FilePath $lockInfoFile -Append -Encoding UTF8
          "" | Out-File -FilePath $lockInfoFile -Append -Encoding UTF8

          if (Test-Path $lockFile) {
            $fileInfo = Get-Item $lockFile
            "锁文件存在: 是" | Out-File -FilePath $lockInfoFile -Append -Encoding UTF8
            "路径: $lockFile" | Out-File -FilePath $lockInfoFile -Append -Encoding UTF8
            "大小: $($fileInfo.Length) 字节" | Out-File -FilePath $lockInfoFile -Append -Encoding UTF8
            "创建时间: $($fileInfo.CreationTime)" | Out-File -FilePath $lockInfoFile -Append -Encoding UTF8
            "修改时间: $($fileInfo.LastWriteTime)" | Out-File -FilePath $lockInfoFile -Append -Encoding UTF8

            $age = (Get-Date) - $fileInfo.LastWriteTime
            "年龄: $([math]::Round($age.TotalSeconds, 2)) 秒" | Out-File -FilePath $lockInfoFile -Append -Encoding UTF8

            # 尝试读取锁文件内容
            try {
              $content = Get-Content $lockFile -Raw -ErrorAction SilentlyContinue
              "内容: $content" | Out-File -FilePath $lockInfoFile -Append -Encoding UTF8
            } catch {
              "无法读取内容: $_" | Out-File -FilePath $lockInfoFile -Append -Encoding UTF8
            }
          } else {
            "锁文件存在: 否" | Out-File -FilePath $lockInfoFile -Append -Encoding UTF8
          }

      - name: 终止测试进程
        if: always()
        run: |
          Write-Host "清理测试进程..."
          $processes = Get-Process -Name "Ai Perf Client" -ErrorAction SilentlyContinue
          if ($processes) {
            Write-Host "发现 $($processes.Count) 个进程，正在终止..."
            $processes | Stop-Process -Force
            Start-Sleep -Seconds 2
          }

      - name: 上传收集的日志
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: windows-exe-test-logs
          path: ${{ env.TEST_DIR }}/collected_logs/**
          retention-days: 30
          if-no-files-found: warn

      - name: 显示监控结果摘要
        if: always()
        run: |
          $logFile = "$env:TEST_DIR\process_monitor.log"
          if (Test-Path $logFile) {
            Write-Host "=== 进程监控摘要 ==="
            Get-Content $logFile | Select-Object -Last 20
          } else {
            Write-Host "监控日志文件不存在"
          }