name: Build Clients

on:
  release:
    types: [published]
  push:
    tags:
      - 'v*'  # 支持 tag push 触发（如 v1.0.0）
  workflow_dispatch:
    inputs:
      client_type:
        description: '客户端类型'
        required: true
        type: choice
        options:
          - employee
          - admin
          - both
        default: both
      platforms:
        description: '打包平台'
        required: true
        type: choice
        options:
          - all
          - macos
          - windows
          - linux
        default: all

jobs:
  build-macos-arm64:
    name: Build macOS (Apple Silicon)
    runs-on: macos-14  # macOS 14 (Sonoma) 支持最低 10.13
    timeout-minutes: 180  # 3小时超时
    if: github.event_name == 'release' || startsWith(github.ref, 'refs/tags/v') || github.event.inputs.platforms == 'all' || github.event.inputs.platforms == 'macos' || github.event.inputs.platforms == ''
    strategy:
      matrix:
        client: [employee, admin]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          architecture: 'arm64'
      
      - name: Install dependencies
        env:
          MACOSX_DEPLOYMENT_TARGET: '10.13'
        run: |
          python3 -m pip install --upgrade pip --break-system-packages
          pip3 install -r requirements.txt --break-system-packages
      
      - name: Verify PyInstaller installation
        run: |
          echo "验证 PyInstaller 安装..."
          python3 -m PyInstaller --version || echo "警告: PyInstaller 未正确安装"
          pip3 list | grep -i pyinstaller || echo "警告: 未找到 PyInstaller 包"
      
      - name: Check if should build
        id: check_build
        run: |
          if [ "${{ github.event_name }}" == "release" ] || \
             [ "${{ github.event_name }}" == "push" ] || \
             [ "${{ github.event.inputs.client_type }}" == "both" ] || \
             [ "${{ github.event.inputs.client_type }}" == "${{ matrix.client }}" ] || \
             [ "${{ github.event.inputs.client_type }}" == "" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi

      - name: Build client (Apple Silicon)
        if: steps.check_build.outputs.should_build == 'true'
        env:
          MACOSX_DEPLOYMENT_TARGET: '10.13'
          PYTHONUNBUFFERED: '1'  # 确保 Python 输出无缓冲，实时显示日志
          SKIP_SIGNING: 'true'  # 跳过签名和公证，仅打包 .app
          GOOGLE_CLIENT_SECRET_JSON: ${{ secrets.GOOGLE_CLIENT_SECRET_JSON }}
        run: |
          cd ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}
          python3 ../scripts/build_client.py ${{ matrix.client }} macos
      
      - name: Upload APP artifact
        if: steps.check_build.outputs.should_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.client }}-macos-arm64-app
          path: ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}/dist/m/*.app
          retention-days: 30

  build-macos-intel:
    name: Build macOS (Intel)
    runs-on: macos-14  # macOS 14 (Sonoma) 支持最低 10.13
    timeout-minutes: 180  # 3小时超时
    if: github.event_name == 'release' || startsWith(github.ref, 'refs/tags/v') || github.event.inputs.platforms == 'all' || github.event.inputs.platforms == 'macos' || github.event.inputs.platforms == ''
    strategy:
      matrix:
        client: [employee, admin]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install gettext (x86_64) for Python x86_64
        run: |
          # 在 Rosetta 环境下安装 x86_64 版本的 gettext
          # 因为 Python x86_64 需要 x86_64 架构的 gettext 库
          # GitHub Actions macOS runner 在 Apple Silicon 上，需要安装 x86_64 版本的 gettext
          echo "在 Rosetta 环境下安装 x86_64 版本的 gettext..."
          
          # 检查现有的 gettext（可能是 arm64 版本）
          if [ -f "/usr/local/opt/gettext/lib/libintl.8.dylib" ]; then
            echo "检测到现有的 gettext，检查架构..."
            file /usr/local/opt/gettext/lib/libintl.8.dylib || true
            # 如果是 arm64 版本，需要安装 x86_64 版本
            if file /usr/local/opt/gettext/lib/libintl.8.dylib 2>/dev/null | grep -q "arm64"; then
              echo "检测到 arm64 版本的 gettext，需要安装 x86_64 版本"
            fi
          fi
          
          # 在 Rosetta 环境下使用 Homebrew 安装 x86_64 版本的 gettext
          # 首先检查 Intel Homebrew 是否存在
          if [ -f "/usr/local/bin/brew" ]; then
            echo "使用 Intel Homebrew (/usr/local/bin/brew) 安装 gettext..."
            arch -x86_64 /usr/local/bin/brew install gettext 2>&1 || {
              echo "尝试重新安装 gettext..."
              arch -x86_64 /usr/local/bin/brew reinstall gettext 2>&1 || echo "警告: gettext 安装/重装失败"
            }
          elif [ -f "/usr/local/Homebrew/bin/brew" ]; then
            echo "使用 Intel Homebrew (/usr/local/Homebrew/bin/brew) 安装 gettext..."
            arch -x86_64 /usr/local/Homebrew/bin/brew install gettext 2>&1 || {
              echo "尝试重新安装 gettext..."
              arch -x86_64 /usr/local/Homebrew/bin/brew reinstall gettext 2>&1 || echo "警告: gettext 安装/重装失败"
            }
          else
            # 如果没有 Intel Homebrew，尝试安装（这可能需要较长时间）
            echo "未找到 Intel Homebrew，尝试安装..."
            echo "注意：这可能需要几分钟时间..."
            arch -x86_64 /bin/bash -c 'CI=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"' || echo "警告: Homebrew 安装失败"
            # 然后安装 gettext
            if [ -f "/usr/local/bin/brew" ]; then
              arch -x86_64 /usr/local/bin/brew install gettext || echo "警告: gettext 安装失败"
            fi
          fi
          
          # 验证 gettext 是否安装成功且是 x86_64 架构
          if [ -f "/usr/local/opt/gettext/lib/libintl.8.dylib" ]; then
            echo "✓ gettext 已安装，检查架构..."
            file /usr/local/opt/gettext/lib/libintl.8.dylib
            # 检查是否是 x86_64 架构
            if file /usr/local/opt/gettext/lib/libintl.8.dylib 2>/dev/null | grep -q "x86_64"; then
              echo "✓ gettext 是 x86_64 架构，可以使用"
            else
              echo "警告: gettext 可能不是 x86_64 架构"
            fi
          else
            echo "警告: gettext 未找到，但继续执行"
          fi
      
      - name: Set up Python (x86_64 via Rosetta)
        id: setup-python
        continue-on-error: true
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          architecture: 'x64'
          cache: 'pip'  # 禁用自动 pip 升级，避免 SSL 错误
      
      - name: Verify Python installation
        run: |
          # 检查 Python 是否安装成功
          if [ -f "${{ steps.setup-python.outputs.python-path }}" ]; then
            echo "✓ Python 已通过 setup-python 安装"
            ${{ steps.setup-python.outputs.python-path }} --version
            # 验证架构
            file_output=$(file "${{ steps.setup-python.outputs.python-path }}" 2>/dev/null || echo "")
            echo "Python 架构信息: $file_output"
          else
            echo "警告: setup-python 失败，尝试使用 Homebrew 安装 x86_64 Python..."
            # 在 Rosetta 环境下安装 Homebrew 到 /usr/local（x86_64 版本）
            # 首先检查 /usr/local 下是否已有 Homebrew
            if [ ! -f "/usr/local/bin/brew" ] && [ ! -f "/usr/local/Homebrew/bin/brew" ]; then
              echo "在 Rosetta 环境下安装 Homebrew 到 /usr/local..."
              # 设置 Homebrew 安装路径为 /usr/local
              export HOMEBREW_PREFIX="/usr/local"
              export HOMEBREW_REPOSITORY="/usr/local/Homebrew"
              # 在 Rosetta 环境下安装 Homebrew
              arch -x86_64 /bin/bash -c '
                CI=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" || {
                  echo "警告: Homebrew 安装可能失败，尝试继续..."
                }
              '
            fi
            
            # 确定 Homebrew 路径
            if [ -f "/usr/local/bin/brew" ]; then
              BREW_CMD="/usr/local/bin/brew"
            elif [ -f "/usr/local/Homebrew/bin/brew" ]; then
              BREW_CMD="/usr/local/Homebrew/bin/brew"
            else
              echo "错误: 无法找到 Homebrew"
              exit 1
            fi
            
            echo "使用 Homebrew: $BREW_CMD"
            # 在 Rosetta 环境下使用 /usr/local 的 Homebrew 安装 Python
            arch -x86_64 /bin/bash -c "
              export PATH=\"/usr/local/bin:/usr/local/sbin:\$PATH\"
              $BREW_CMD install python@3.10 || $BREW_CMD upgrade python@3.10 || {
                echo '警告: Python 安装/升级失败，尝试继续...'
              }
              echo '✓ Python 安装完成'
            "
            
            # 查找 Homebrew 安装的 Python（优先使用 /usr/local）
            HOMEBREW_PYTHON="/usr/local/opt/python@3.10/bin/python3"
            if [ ! -f "$HOMEBREW_PYTHON" ]; then
              # 尝试其他可能的路径
              HOMEBREW_PYTHON="/usr/local/bin/python3"
            fi
            
            if [ -f "$HOMEBREW_PYTHON" ]; then
              echo "✓ 找到 Homebrew Python: $HOMEBREW_PYTHON"
              echo "homebrew-python-path=$HOMEBREW_PYTHON" >> $GITHUB_OUTPUT
              arch -x86_64 "$HOMEBREW_PYTHON" --version || "$HOMEBREW_PYTHON" --version
            else
              echo "错误: 未找到 Python"
              echo "尝试查找所有可能的 Python 路径..."
              arch -x86_64 /bin/bash -c 'ls -la /usr/local/bin/python3* 2>/dev/null || echo "未找到 /usr/local/bin/python3"'
              arch -x86_64 /bin/bash -c 'ls -la /usr/local/opt/python@3.10/bin/python3* 2>/dev/null || echo "未找到 /usr/local/opt/python@3.10/bin/python3"'
              exit 1
            fi
          fi
      
      - name: Install dependencies
        env:
          MACOSX_DEPLOYMENT_TARGET: '10.13'
        run: |
          # 优先使用 Homebrew Python（x86_64，位于 /usr/local）
          # 明确使用 /usr/local 下的 Homebrew，避免使用 /opt/homebrew（ARM64）
          HOMEBREW_PREFIX="/usr/local"
          
          # 检查 setup-python 的 Python 是否有 SSL 支持（如果存在）
          if [ -f "${{ steps.setup-python.outputs.python-path }}" ]; then
            SETUP_PYTHON="${{ steps.setup-python.outputs.python-path }}"
            # 检查是否是 /opt/homebrew（ARM64），如果是则跳过
            if echo "$SETUP_PYTHON" | grep -q "/opt/homebrew"; then
              echo "警告: setup-python 返回的是 ARM64 Python (/opt/homebrew)，跳过"
              SETUP_PYTHON=""
            elif arch -x86_64 "$SETUP_PYTHON" -c "import ssl; print('SSL OK')" 2>/dev/null; then
              echo "✓ setup-python Python 有 SSL 支持"
              PYTHON_CMD="$SETUP_PYTHON"
            else
              echo "警告: setup-python Python 缺少 SSL 支持，使用 Homebrew Python"
              SETUP_PYTHON=""
            fi
          fi
          
          # 如果没有可用的 setup-python Python，使用 Homebrew Python
          if [ -z "$PYTHON_CMD" ]; then
            # 优先查找 /usr/local 下的 Homebrew Python（x86_64）
            HOMEBREW_PYTHON="$HOMEBREW_PREFIX/opt/python@3.10/bin/python3"
            if [ -f "$HOMEBREW_PYTHON" ]; then
              PYTHON_CMD="$HOMEBREW_PYTHON"
              echo "使用 Homebrew Python: $PYTHON_CMD"
            elif [ -f "$HOMEBREW_PREFIX/bin/python3" ]; then
              PYTHON_CMD="$HOMEBREW_PREFIX/bin/python3"
              echo "使用 Homebrew Python (备用路径): $PYTHON_CMD"
            else
              echo "警告: 未找到 Homebrew Python，尝试安装..."
              # 确保 Intel Homebrew 存在
              if [ ! -f "/usr/local/bin/brew" ] && [ ! -f "/usr/local/Homebrew/bin/brew" ]; then
                echo "在 Rosetta 环境下安装 Homebrew 到 /usr/local..."
                export HOMEBREW_PREFIX="/usr/local"
                export HOMEBREW_REPOSITORY="/usr/local/Homebrew"
                arch -x86_64 /bin/bash -c '
                  CI=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" || true
                '
              fi
              
              BREW_CMD="/usr/local/bin/brew"
              [ -f "$BREW_CMD" ] || BREW_CMD="/usr/local/Homebrew/bin/brew"
              
              if [ -f "$BREW_CMD" ]; then
                echo "使用 Homebrew 安装 Python 3.10..."
                arch -x86_64 /bin/bash -c "
                  export PATH=\"/usr/local/bin:/usr/local/sbin:\$PATH\"
                  export HOMEBREW_PREFIX=\"/usr/local\"
                  $BREW_CMD install python@3.10 || $BREW_CMD upgrade python@3.10 || true
                "
                HOMEBREW_PYTHON="/usr/local/opt/python@3.10/bin/python3"
                if [ -f "$HOMEBREW_PYTHON" ]; then
                  PYTHON_CMD="$HOMEBREW_PYTHON"
                  echo "✓ Homebrew Python 已安装: $PYTHON_CMD"
                else
                  echo "错误: 无法安装 Homebrew Python"
                  exit 1
                fi
              else
                echo "错误: 无法找到或安装 Homebrew"
                exit 1
              fi
            fi
          fi
          
          # 验证 Python 路径不是 ARM64 版本
          if echo "$PYTHON_CMD" | grep -q "/opt/homebrew"; then
            echo "错误: 检测到 ARM64 Python 路径 (/opt/homebrew)，必须使用 x86_64 Python"
            exit 1
          fi
          
          echo "使用 Python: $PYTHON_CMD"
          # 验证 Python 是否可用（必须在 Rosetta 环境下运行）
          arch -x86_64 "$PYTHON_CMD" --version || {
            echo "错误: Python 无法在 x86_64 架构下运行"
            echo "Python 路径: $PYTHON_CMD"
            file "$PYTHON_CMD" || echo "无法检查 Python 架构"
            exit 1
          }
          
          # 验证 SSL 支持
          if ! arch -x86_64 "$PYTHON_CMD" -c "import ssl; print('SSL OK')" 2>/dev/null; then
            echo "错误: Python 缺少 SSL 模块支持"
            exit 1
          fi
          
          echo "Python 路径验证:"
          file "$PYTHON_CMD" || echo "无法检查 Python 架构"
          
          # 安装依赖（必须在 Rosetta 环境下运行，使用 pip3）
          arch -x86_64 "$PYTHON_CMD" -m pip install --upgrade pip --break-system-packages
          arch -x86_64 "$PYTHON_CMD" -m pip install -r requirements.txt --break-system-packages
      
      - name: Verify PyInstaller installation
        run: |
          # 使用相同的 Python 命令查找逻辑（优先使用 /usr/local 下的 Homebrew Python）
          HOMEBREW_PREFIX="/usr/local"
          if [ -f "$HOMEBREW_PREFIX/opt/python@3.10/bin/python3" ]; then
            PYTHON_CMD="$HOMEBREW_PREFIX/opt/python@3.10/bin/python3"
          elif [ -f "$HOMEBREW_PREFIX/bin/python3" ]; then
            PYTHON_CMD="$HOMEBREW_PREFIX/bin/python3"
          elif [ -f "${{ steps.setup-python.outputs.python-path }}" ] && ! echo "${{ steps.setup-python.outputs.python-path }}" | grep -q "/opt/homebrew"; then
            PYTHON_CMD="${{ steps.setup-python.outputs.python-path }}"
          else
            echo "错误: 无法找到可用的 x86_64 Python"
            exit 1
          fi
          
          # 验证不是 ARM64 版本
          if echo "$PYTHON_CMD" | grep -q "/opt/homebrew"; then
            echo "错误: 检测到 ARM64 Python 路径"
            exit 1
          fi
          
          echo "验证 PyInstaller 安装..."
          arch -x86_64 "$PYTHON_CMD" -m PyInstaller --version || echo "警告: PyInstaller 未正确安装"
          arch -x86_64 "$PYTHON_CMD" -m pip list | grep -i pyinstaller || echo "警告: 未找到 PyInstaller 包"
      
      - name: Check if should build
        id: check_build
        run: |
          if [ "${{ github.event_name }}" == "release" ] || \
             [ "${{ github.event_name }}" == "push" ] || \
             [ "${{ github.event.inputs.client_type }}" == "both" ] || \
             [ "${{ github.event.inputs.client_type }}" == "${{ matrix.client }}" ] || \
             [ "${{ github.event.inputs.client_type }}" == "" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Build client (Intel)
        if: steps.check_build.outputs.should_build == 'true'
        env:
          MACOSX_DEPLOYMENT_TARGET: '10.13'
          PYTHONUNBUFFERED: '1'  # 确保 Python 输出无缓冲，实时显示日志
          SKIP_SIGNING: 'true'  # 跳过签名和公证，仅打包 .app
          GOOGLE_CLIENT_SECRET_JSON: ${{ secrets.GOOGLE_CLIENT_SECRET_JSON }}
        run: |
          cd ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}
          # 使用 Homebrew Python（x86_64，位于 /usr/local）
          HOMEBREW_PREFIX="/usr/local"
          if [ -f "$HOMEBREW_PREFIX/opt/python@3.10/bin/python3" ]; then
            PYTHON_CMD="$HOMEBREW_PREFIX/opt/python@3.10/bin/python3"
          elif [ -f "$HOMEBREW_PREFIX/bin/python3" ]; then
            PYTHON_CMD="$HOMEBREW_PREFIX/bin/python3"
          elif [ -f "${{ steps.setup-python.outputs.python-path }}" ] && ! echo "${{ steps.setup-python.outputs.python-path }}" | grep -q "/opt/homebrew"; then
            PYTHON_CMD="${{ steps.setup-python.outputs.python-path }}"
          else
            echo "错误: 无法找到可用的 x86_64 Python"
            exit 1
          fi
          
          # 验证不是 ARM64 版本
          if echo "$PYTHON_CMD" | grep -q "/opt/homebrew"; then
            echo "错误: 检测到 ARM64 Python 路径 (/opt/homebrew)，必须使用 x86_64 Python"
            exit 1
          fi
          
          echo "使用 Python: $PYTHON_CMD"
          arch -x86_64 "$PYTHON_CMD" --version || {
            echo "错误: Python 无法在 x86_64 架构下运行"
            file "$PYTHON_CMD" || echo "无法检查 Python 架构"
            exit 1
          }
          echo "开始构建..."
          arch -x86_64 "$PYTHON_CMD" ../scripts/build_client.py ${{ matrix.client }} macos
      
      - name: Upload APP artifact
        if: steps.check_build.outputs.should_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.client }}-macos-intel-app
          path: ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}/dist/intel/*.app
          retention-days: 30

  build-windows:
    name: Build Windows
    runs-on: windows-latest
    timeout-minutes: 120  # 2小时超时
    if: github.event_name == 'release' || startsWith(github.ref, 'refs/tags/v') || github.event.inputs.platforms == 'all' || github.event.inputs.platforms == 'windows' || github.event.inputs.platforms == ''
    strategy:
      matrix:
        client: [employee, admin]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          architecture: 'x64'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          # Windows 上通常不需要 --break-system-packages，但为了保险起见，如果遇到错误可以添加
      
      - name: Verify PyInstaller installation
        run: |
          echo "验证 PyInstaller 安装..."
          python -m PyInstaller --version || echo "警告: PyInstaller 未正确安装"
          pip list | findstr /i pyinstaller || echo "警告: 未找到 PyInstaller 包"
      
      - name: Install Inno Setup
        run: |
          choco install innosetup -y
        continue-on-error: true
      
      - name: Install WiX Toolset
        run: |
          choco install wixtoolset -y
        continue-on-error: true
      
      - name: Check if should build
        id: check_build
        shell: bash
        run: |
          if [ "${{ github.event_name }}" == "release" ] || \
             [ "${{ github.event.inputs.client_type }}" == "both" ] || \
             [ "${{ github.event.inputs.client_type }}" == "${{ matrix.client }}" ] || \
             [ "${{ github.event.inputs.client_type }}" == "" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Build client (Windows)
        if: steps.check_build.outputs.should_build == 'true'
        env:
          PYTHONUNBUFFERED: '1'  # 确保 Python 输出无缓冲，实时显示日志
          GOOGLE_CLIENT_SECRET_JSON: ${{ secrets.GOOGLE_CLIENT_SECRET_JSON }}
        run: |
          cd ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}
          python ../scripts/build_client.py ${{ matrix.client }} windows
      
      - name: Upload EXE artifact
        if: steps.check_build.outputs.should_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.client }}-windows-exe
          path: ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}/dist/*.exe
          retention-days: 30
      
      - name: Upload MSI artifact
        if: steps.check_build.outputs.should_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.client }}-windows-msi
          path: ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}/dist/*.msi
          retention-days: 30
          if-no-files-found: ignore

  build-linux-ubuntu:
    name: Build Linux (Ubuntu/Debian)
    runs-on: ubuntu-22.04
    timeout-minutes: 120  # 2小时超时
    if: github.event_name == 'release' || startsWith(github.ref, 'refs/tags/v') || github.event.inputs.platforms == 'all' || github.event.inputs.platforms == 'linux' || github.event.inputs.platforms == ''
    strategy:
      matrix:
        client: [employee, admin]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Install system dependencies
        run: |
          sudo apt-get update
          # 安装 DEB 打包工具
          sudo apt-get install -y \
            dpkg-dev \
            fakeroot \
            build-essential \
            libgl1-mesa-glx \
            libxkbcommon-x11-0 \
            libxcb-xinerama0 \
            libxcb-cursor0
          # 安装 RPM 打包工具（rpmbuild 包含在 rpm 包中）
          # 在 Ubuntu 上，rpm 包提供了 rpmbuild 工具
          sudo apt-get install -y rpm || echo "警告: rpm 包安装失败，RPM 打包将不可用"
          # 验证 rpmbuild 是否可用
          which rpmbuild || echo "警告: rpmbuild 未找到，RPM 打包将不可用"
      
      - name: Install Python dependencies
        run: |
          python3 -m pip install --upgrade pip --break-system-packages
          pip3 install -r requirements.txt --break-system-packages
      
      - name: Verify PyInstaller installation
        run: |
          echo "验证 PyInstaller 安装..."
          python3 -m PyInstaller --version || echo "警告: PyInstaller 未正确安装"
          pip3 list | grep -i pyinstaller || echo "警告: 未找到 PyInstaller 包"
      
      - name: Check if should build
        id: check_build
        run: |
          if [ "${{ github.event_name }}" == "release" ] || \
             [ "${{ github.event_name }}" == "push" ] || \
             [ "${{ github.event.inputs.client_type }}" == "both" ] || \
             [ "${{ github.event.inputs.client_type }}" == "${{ matrix.client }}" ] || \
             [ "${{ github.event.inputs.client_type }}" == "" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Build client (Linux)
        if: steps.check_build.outputs.should_build == 'true'
        env:
          PYTHONUNBUFFERED: '1'  # 确保 Python 输出无缓冲，实时显示日志
          GOOGLE_CLIENT_SECRET_JSON: ${{ secrets.GOOGLE_CLIENT_SECRET_JSON }}
        run: |
          cd ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}
          python3 ../scripts/build_client.py ${{ matrix.client }} linux
      
      - name: Upload DEB artifact
        if: steps.check_build.outputs.should_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.client }}-linux-deb
          path: ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}/dist/*.deb
          retention-days: 30
          if-no-files-found: ignore
      
      - name: Upload RPM artifact
        if: steps.check_build.outputs.should_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.client }}-linux-rpm
          path: ${{ matrix.client == 'employee' && 'ui_client' || 'admin_ui_client' }}/dist/*.rpm
          retention-days: 30
          if-no-files-found: ignore

  create-release:
    name: Create Release
    needs: [build-macos-arm64, build-macos-intel, build-windows, build-linux-ubuntu]
    runs-on: ubuntu-latest
    if: github.event_name == 'release' || startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      
      - name: Determine tag name
        id: tag_name
        run: |
          if [ "${{ github.event_name }}" == "release" ]; then
            echo "tag=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "push" ]; then
            # 从 refs/tags/v1.0.0 提取 v1.0.0
            TAG_NAME=${GITHUB_REF#refs/tags/}
            echo "tag=${TAG_NAME}" >> $GITHUB_OUTPUT
          fi
      
      - name: Filter release files
        run: |
          # 创建 release_files 目录
          mkdir -p release_files
          
          # 复制 .app 目录并打包成 ZIP（macOS 应用包是目录，需要打包）
          # 只保留主应用，过滤掉 QtWebEngineProcess.app 等辅助应用
          # 根据 artifact 目录名判断架构（格式：{client}-macos-{arch}-app）
          find artifacts -type d -name "*.app" | while read app_path; do
            app_name=$(basename "$app_path")
            # 过滤掉 QtWebEngineProcess.app 等辅助应用
            if [[ "$app_name" != "QtWebEngineProcess.app" ]]; then
              # 从完整路径中提取 artifact 目录名
              # 路径格式：artifacts/{client}-macos-{arch}-app/.../{app_name}.app
              arch="unknown"
              
              # 方法1: 从 artifact 目录名提取（优先级最高）
              # 查找路径中的 artifact 目录（包含 -macos- 的目录）
              # 使用 sed 替代 grep -oE，避免兼容性问题
              artifact_dir=$(echo "$app_path" | sed -n 's|.*\(artifacts/[^/]*-macos-[^/]*-app\).*|\1|p' | head -n 1)
              if [[ -n "$artifact_dir" ]]; then
                # 提取架构部分：{client}-macos-{arch}-app
                artifact_name=$(basename "$artifact_dir")
                if echo "$artifact_name" | grep -qE "-macos-arm64-app$"; then
                  arch="arm64"
                elif echo "$artifact_name" | grep -qE "-macos-intel-app$"; then
                  arch="intel"
                fi
              fi
              
              # 方法2: 如果方法1失败，尝试从路径中查找架构目录
              if [[ "$arch" == "unknown" ]]; then
                if echo "$app_path" | grep -qE "/(arm64|m)/"; then
                  arch="arm64"
                elif echo "$app_path" | grep -q "/intel/"; then
                  arch="intel"
                fi
              fi
              
              # 生成带架构信息的 ZIP 文件名
              # 如果架构未知，尝试从路径中提取更多信息
              if [[ "$arch" == "unknown" ]]; then
                # 尝试从完整路径中提取更多信息
                if echo "$app_path" | grep -q "employee-macos-arm64-app"; then
                  arch="arm64"
                elif echo "$app_path" | grep -q "employee-macos-intel-app"; then
                  arch="intel"
                elif echo "$app_path" | grep -q "admin-macos-arm64-app"; then
                  arch="arm64"
                elif echo "$app_path" | grep -q "admin-macos-intel-app"; then
                  arch="intel"
                fi
              fi
              
              # 生成 ZIP 文件名（确保唯一性）
              if [[ "$arch" != "unknown" ]]; then
                zip_name="${app_name}-${arch}.zip"
              else
                # 如果架构仍然未知，使用路径中的信息生成唯一文件名
                # 从路径中提取客户端类型和可能的架构
                if echo "$app_path" | grep -q "employee"; then
                  client_suffix="employee"
                elif echo "$app_path" | grep -q "admin"; then
                  client_suffix="admin"
                else
                  client_suffix="unknown"
                fi
                zip_name="${app_name}-${client_suffix}.zip"
                echo "⚠ 警告: 无法确定架构，使用 ${client_suffix} 作为后缀"
              fi
              
              echo "打包 $app_name ($arch) -> $zip_name..."
              echo "  路径: $app_path"
              
              # 检查是否已存在同名文件（避免覆盖）
              if [[ -f "release_files/${zip_name}" ]]; then
                echo "⚠ 警告: ${zip_name} 已存在，生成唯一文件名..."
                # 从路径中提取更多信息生成唯一文件名
                if echo "$app_path" | grep -q "employee-macos-arm64-app"; then
                  zip_name="${app_name}-employee-arm64.zip"
                elif echo "$app_path" | grep -q "employee-macos-intel-app"; then
                  zip_name="${app_name}-employee-intel.zip"
                elif echo "$app_path" | grep -q "admin-macos-arm64-app"; then
                  zip_name="${app_name}-admin-arm64.zip"
                elif echo "$app_path" | grep -q "admin-macos-intel-app"; then
                  zip_name="${app_name}-admin-intel.zip"
                else
                  # 使用时间戳确保唯一性
                  zip_name="${app_name}-$(date +%s).zip"
                fi
                echo "  使用唯一文件名: $zip_name"
              fi
              
              # 使用最高压缩级别（-9）和排除不必要的文件
              zip -r -9 "release_files/${zip_name}" "$app_path" -q \
                -x "*.DS_Store" \
                -x "*__pycache__*" \
                -x "*.pyc" \
                -x "*.pyo" \
                -x "*.pyd" \
                -x ".git/*" \
                -x ".gitignore" \
                -x "*.log" \
                -x "*.tmp" \
                -x "*.bak"
              
              # 检查文件大小（GitHub 限制 2 GB = 2147483648 字节）
              if command -v stat >/dev/null 2>&1; then
                # macOS 使用 stat -f%z，Linux 使用 stat -c%s
                file_size=$(stat -f%z "release_files/${zip_name}" 2>/dev/null || stat -c%s "release_files/${zip_name}" 2>/dev/null || echo "0")
                file_size_mb=$(echo "scale=2; $file_size / 1048576" | bc 2>/dev/null || awk "BEGIN {printf \"%.2f\", $file_size / 1048576}")
                
                # 检查是否超过 2 GB（2147483648 字节）
                if [ "$file_size" -gt 2147483648 ] 2>/dev/null; then
                  echo "⚠ 警告: $zip_name 大小 ${file_size_mb} MB (${file_size} 字节)，超过 GitHub 2 GB 限制，将跳过上传"
                  rm -f "release_files/${zip_name}"
                else
                  echo "✓ $zip_name 大小: ${file_size_mb} MB"
                fi
              else
                echo "⚠ 无法检查文件大小，继续上传 $zip_name"
              fi
            fi
          done
          
          # 复制安装包文件（.dmg, .pkg, .exe, .msi, .deb, .rpm）
          find artifacts -type f \( \
            -name "*.dmg" -o \
            -name "*.pkg" -o \
            -name "*.exe" -o \
            -name "*.msi" -o \
            -name "*.deb" -o \
            -name "*.rpm" \
          \) -exec cp {} release_files/ \;
          
          # 显示要上传的文件
          echo ""
          echo "准备上传的文件："
          ls -lh release_files/ || echo "未找到安装包文件"
          
          # 检查是否有文件超过 2 GB
          echo ""
          echo "文件大小检查："
          for file in release_files/*; do
            if [ -f "$file" ]; then
              file_name=$(basename "$file")
              # macOS 使用 stat -f%z，Linux 使用 stat -c%s
              file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
              file_size_mb=$(echo "scale=2; $file_size / 1048576" | bc 2>/dev/null || awk "BEGIN {printf \"%.2f\", $file_size / 1048576}")
              
              # 检查是否超过 2 GB（2147483648 字节）
              if [ "$file_size" -gt 2147483648 ] 2>/dev/null; then
                echo "✗ $file_name: ${file_size_mb} MB (超过 2 GB 限制，将被跳过)"
                rm -f "$file"
              else
                echo "✓ $file_name: ${file_size_mb} MB"
              fi
            fi
          done
      
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.tag_name.outputs.tag }}
          name: Release ${{ steps.tag_name.outputs.tag }}
          files: release_files/*
          draft: false
          prerelease: false
          fail_on_unmatched_files: false  # 如果没有文件也不失败
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
